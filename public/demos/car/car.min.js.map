{
  "version": 3,
  "sources": ["../../../../dasl-tiles/lib/el.js", "../../../../dasl-tiles/loader.js", "../../../../dasl-tiles/node_modules/@atcute/uint8array/lib/index.ts", "../../../../dasl-tiles/node_modules/@atcute/multibase/lib/utils.ts", "../../../../dasl-tiles/node_modules/@atcute/multibase/lib/bases/base64-web-native.ts", "../../../../dasl-tiles/node_modules/@atcute/multibase/lib/bases/base64-web-polyfill.ts", "../../../../dasl-tiles/node_modules/@atcute/multibase/lib/bases/base64-web.ts", "../../../../dasl-tiles/node_modules/@atcute/multibase/lib/bases/base32.ts", "../../../../dasl-tiles/node_modules/@atcute/cid/lib/codec.ts", "../../../../dasl-tiles/node_modules/@atcute/cid/lib/cid-link.ts", "../../../../dasl-tiles/node_modules/@atcute/cbor/lib/bytes.ts", "../../../../dasl-tiles/node_modules/@atcute/cbor/lib/decode.ts", "../../../../dasl-tiles/node_modules/@atcute/varint/lib/index.ts", "../../../../dasl-tiles/node_modules/@atcute/car/lib/types.ts", "../../../../dasl-tiles/node_modules/@atcute/car/lib/reader.ts", "../../../../dasl-tiles/loader/content-scheme.js", "../../../../dasl-tiles/lib/masl.js", "../../../../dasl-tiles/loader/car.js", "car.js"],
  "sourcesContent": ["\nexport function el (n, attrs, kids, p) {\n  const e = document.createElement(n);\n  Object.entries(attrs || {}).forEach(([k, v]) => {\n    if (v == null) return;\n    if (k === 'style') {\n      Object.entries(v).forEach(([prop, value]) => {\n        const snake = prop\n          .split('-')\n          .map((part, idx) => idx ? part.charAt(0).toUpperCase() + part.slice(1) : part)\n          .join('');\n        e.style[snake] = value;\n      });\n      return;\n    }\n    e.setAttribute(k, v);\n  });\n  (kids || []).forEach((n) => {\n    if (typeof n === 'string') e.append(txt(n));\n    else e.append(n);\n  });\n  if (p) p.append(e);\n  return e;\n}\n\nfunction txt (str) {\n  return document.createTextNode(str);\n}\n", "\n/*\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n\u255A\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255D\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\n   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u255D  \u255A\u2550\u2550\u2550\u2550\u2588\u2588\u2551\n   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n   \u255A\u2550\u255D   \u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n      \u2022--~~~## MOTHERSHIP ##~~~--\u2022\n\nThe tile-loading architecture has three levels that all communicate together:\n\n- At the top, the MOTHERSHIP. This has access to things in the real world like\n  fetching from the internet or reading from the file system. It's the interface\n  to tile loading, it gets configured in ways that are appropriate for its\n  context. This is the entry point: you give it a URL and it'll instantiate that\n  tile. To the extent possible, this should contain all the intelligence and all\n  the configurability so that the other components can be deployed in entirely\n  generic ways.\n- The mothership instantiates tiles by creating insulated contexts (a sandboxed\n  iframe, an incognito window\u2026) and loading a SHUTTLE in it. The role of the\n  shuttle is to set up a service worker and an iframe to load the root of the\n  tile into. It only exists because you need something to carry a service worker\n  in. The only other thing that it does is (*drumroll*) shuttle messages back\n  and forth between the worker and the mothership.\n- The WORKER is dispatched on a shuttle to handle resource loading for a tile.\n  Apart from allow-listing some paths for itself and the shuttle, it passes all\n  requests up, which the shuttle then hands over to the mothership.\n*/\n\nimport { el } from \"./lib/el.js\";\n\nconst TILES_PFX = 'tiles-';\nconst SHUTTLE_PFX = 'tiles-shuttle-';\nconst SND_SHUTTLE_LOAD = `${SHUTTLE_PFX}load`;        // tell worker to roll\nconst RCV_SHUTTLE_READY = `${SHUTTLE_PFX}ready`;      // worker ready\nconst SND_SET_TITLE = `${SHUTTLE_PFX}set-title`;      // set the title\nconst SND_SET_ICON = `${SHUTTLE_PFX}set-icon`;        // set the icon\nconst WORKER_PFX = 'tiles-worker-';\nconst SND_WORKER_LOAD = `${WORKER_PFX}load`;          // tell worker to roll\nconst RCV_WORKER_READY = `${WORKER_PFX}ready`;        // worker ready\nconst RCV_WORKER_REQUEST = `${WORKER_PFX}request`;    // worker requested something\nconst SND_WORKER_RESPONSE = `${WORKER_PFX}response`;  // respond to a worker\nconst TILES_WARNING = `${TILES_PFX}warn`;             // worker warnings\nconst TILES_ERROR = `${TILES_PFX}error`;              // shuttle errors\n\nexport class TileMothership {\n  #loaders = [];\n  #conf = {};\n  #id2shuttle = new Map();\n  #id2tile = new Map();\n  constructor (conf) {\n    this.#conf = conf;\n  }\n  init () {\n    window.addEventListener('message', async (ev) => {\n      const { action } = ev.data || {};\n      if (action === TILES_WARNING) {\n        const { msg, id } = ev.data;\n        console.warn(`[W:${id}]`, ...msg);\n      }\n      if (action === TILES_ERROR) {\n        const { msg, id } = ev.data;\n        console.error(`[S:${id}]`, ...msg);\n      }\n      else if (action === RCV_SHUTTLE_READY) {\n        const { id } = ev.data;\n        console.info(`[W:${id}] shuttle ready!`);\n        this.sendToShuttle(id, SND_WORKER_LOAD, { id });\n      }\n      else if (action === RCV_WORKER_READY) {\n        const { id } = ev.data;\n        console.info(`[W:${id}] worker ready!`);\n        const tile = this.#id2tile.get(id);\n        if (!tile) throw new Error(`No tile shuttle with ID ${id}`);\n        tile.dispatchEvent(new Event('load'));\n      }\n      else if (action === RCV_WORKER_REQUEST) {\n        const { type, id, payload } = ev.data;\n        console.info(`[W:${id}] worker request`, type, id, payload);\n        if (type === 'resolve-path') {\n          const { path, requestId } = payload;\n          const tile = this.#id2tile.get(id);\n          if (!tile) throw new Error(`No tile shuttle with ID ${id}`);\n          const { status, headers, body } = await tile.resolvePath(path);\n          console.info(`[W:${id}] sending back`, status, headers, body);\n          this.sendToShuttle(id, SND_WORKER_RESPONSE, { requestId, response: { status, headers, body } });\n        }\n      }\n    });\n  }\n  sendToShuttle (id, action, payload) {\n    console.warn(`sendToShuttle`, id, action, payload);\n    const ifr = this.#id2shuttle.get(id);\n    if (!ifr) return console.error(`No shuttle for ID ${id}`);\n    ifr.contentWindow.postMessage({ id, action, payload }, '*');\n  }\n  registerShuttleFrame (ifr, tile) {\n    const id = crypto.randomUUID(); // we might want to make that pluggable\n    this.#id2shuttle.set(id, ifr);\n    this.#id2tile.set(id, tile);\n    return id;\n  }\n  startShuttle (id) {\n    this.sendToShuttle(id, SND_SHUTTLE_LOAD, { id });\n  }\n  // Adds a loader that will handle matching requests to load a tile.\n  // - `loader` is an object that knows how to load a tile for a specific scheme\n  //    (and types)\n  addLoader (loader) {\n    this.#loaders.push(loader);\n  }\n  // Remove using same reference.\n  removeLoader (loader) {\n    this.#loaders = this.#loaders.filter(ldr => ldr !== loader);\n  }\n  getLoadSource () {\n    return `https://${this.#conf?.loadDomain || 'load.webtil.es'}/.well-known/web-tiles/`;\n  }\n  // Load a tile.\n  async loadTile (url) {\n    let tile = false;\n    for (const ldr of this.#loaders) {\n      tile = await ldr.load(url, this);\n      if (tile) break;\n    }\n    return tile;\n  }\n}\n\nexport class Tile extends EventTarget {\n  #mothership;\n  #url;\n  #manifest;\n  #pathLoader;\n  #shuttleId;\n  constructor (mothership, url, manifest, pathLoader) {\n    super();\n    this.#mothership = mothership;\n    this.#url = url;\n    this.#manifest = manifest;\n    this.#pathLoader = pathLoader;\n    this.addEventListener('load', () => {\n      if (this.#manifest?.name) {\n        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_TITLE, { title: this.#manifest?.name });\n      }\n      const icon = this.#manifest?.icons?.[0]?.src;\n      if (icon) {\n        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_ICON, { path: icon });\n      }\n    });\n  }\n  get url () {\n    return this.#url;\n  }\n  get manifest () {\n    return this.#manifest;\n  }\n  async resolvePath (path) {\n    const u = new URL(`fake:${path}`);\n    return this.#pathLoader.resolvePath(u.pathname);\n  }\n  async renderCard (options) {\n    const card = el('div', { style: {\n      border: '1px solid lightgrey',\n      'border-radius': '3px',\n      cursor: 'pointer',\n    }});\n    card.addEventListener('click', async () => {\n      const tileRenderer = await this.renderContent(\n        options?.contentHeight ||\n        this.#manifest?.sizing?.height ||\n        Math.max(card.offsetHeight, 300)\n      );\n      card.replaceWith(tileRenderer);\n    });\n    // XXX we always take the first, we could be smarter with sizes\n    if (this.#manifest?.screenshots?.[0]?.src) {\n      const res = await this.resolvePath(this.#manifest.screenshots[0].src);\n      if (res.ok) {\n        const blob = new Blob([res.body], { type: res.headers?.['content-type'] });\n        const url = URL.createObjectURL(blob);\n        el('div', { style: {\n          'background-image': `url(${url})`,\n          'background-size': 'cover',\n          'background-position': '50%',\n          'aspect-ratio': '16/9',\n        }}, [], card);\n      }\n    }\n    const title = el('div', { style: {\n      padding: '0.5rem 1rem',\n      display: 'flex',\n      'align-items': 'center',\n    }}, [], card);\n    // XXX we always take the first, we could be smarter with sizes\n    if (this.#manifest?.icons?.[0]?.src) {\n      const res = await this.resolvePath(this.#manifest.icons[0].src);\n      if (res.ok) {\n        const blob = new Blob([res.body], { type: res.headers?.['content-type'] });\n        const url = URL.createObjectURL(blob);\n        el('img', { src: url, width: '48', height: '48', alt: 'icon', style: { 'padding-right': '0.5rem' } }, [], title);\n      }\n    }\n    el('span', { style: { 'font-weight': 'bold' } }, [this.#manifest.name || 'Untitled Tile'], title);\n    if (this.#manifest.description) {\n      el('p', { style: { 'margin': '0.5rem 1rem 1rem 1rem' } }, [this.#manifest.description], card);\n    }\n    return card;\n  }\n  async renderContent (height = 300) {\n    const ifr = el('iframe', {\n      src: this.#mothership.getLoadSource(),\n      style: {\n        display: 'block',\n        width: '100%',\n        height: `${height}px`,\n        border: 'none',\n      }\n    });\n    this.#shuttleId = this.#mothership.registerShuttleFrame(ifr, this);\n    ifr.addEventListener('load', () => this.#mothership.startShuttle(this.#shuttleId));\n    return ifr;\n  }\n}\n", "const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\nconst subtle = crypto.subtle;\n\n/**\n * creates an Uint8Array of the requested size, with the contents zeroed\n */\nexport const alloc = (size: number): Uint8Array<ArrayBuffer> => {\n\treturn new Uint8Array(size);\n};\n\n/**\n * creates an Uint8Array of the requested size, where the contents may not be\n * zeroed out. only use if you're certain that the contents will be overwritten\n */\nexport const allocUnsafe = alloc;\n\n/**\n * compares two Uint8Array buffers\n */\nexport const compare = (a: Uint8Array, b: Uint8Array): number => {\n\tconst alen = a.length;\n\tconst blen = b.length;\n\n\tif (alen > blen) {\n\t\treturn 1;\n\t}\n\tif (alen < blen) {\n\t\treturn -1;\n\t}\n\n\tfor (let i = 0; i < alen; i++) {\n\t\tconst ax = a[i];\n\t\tconst bx = b[i];\n\n\t\tif (ax < bx) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ax > bx) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n};\n\n/**\n * checks if the two Uint8Array buffers are equal\n */\nexport const equals = (a: Uint8Array, b: Uint8Array): boolean => {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tlet len: number;\n\tif ((len = a.length) === b.length) {\n\t\twhile (len--) {\n\t\t\tif (a[len] !== b[len]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn len === -1;\n};\n\n/**\n * checks if the two Uint8Array buffers are equal, timing-safe version\n */\nexport const timingSafeEquals = (a: Uint8Array, b: Uint8Array): boolean => {\n\tlet len: number;\n\tlet out = 0;\n\tif ((len = a.length) === b.length) {\n\t\twhile (len--) {\n\t\t\tout |= a[len] ^ b[len];\n\t\t}\n\t}\n\n\treturn len === -1 && out === 0;\n};\n\n/**\n * concatenates multiple Uint8Array buffers into one\n */\nexport const concat = (arrays: Uint8Array[], size?: number): Uint8Array<ArrayBuffer> => {\n\tlet written = 0;\n\n\tlet len = arrays.length;\n\tlet idx: number;\n\n\tif (size === undefined) {\n\t\tfor (idx = size = 0; idx < len; idx++) {\n\t\t\tconst chunk = arrays[idx];\n\t\t\tsize += chunk.length;\n\t\t}\n\t}\n\n\tconst buffer = new Uint8Array(size);\n\n\tfor (idx = 0; idx < len; idx++) {\n\t\tconst chunk = arrays[idx];\n\n\t\tbuffer.set(chunk, written);\n\t\twritten += chunk.length;\n\t}\n\n\treturn buffer;\n};\n\n/**\n * encodes a UTF-8 string\n */\nexport const encodeUtf8 = (str: string): Uint8Array<ArrayBuffer> => {\n\treturn textEncoder.encode(str);\n};\n\n/**\n * encodes a UTF-8 string into a given buffer\n */\nexport const encodeUtf8Into = (to: Uint8Array, str: string, offset?: number, length?: number): number => {\n\tlet buffer: Uint8Array;\n\n\tif (offset === undefined) {\n\t\tbuffer = to;\n\t} else if (length === undefined) {\n\t\tbuffer = to.subarray(offset);\n\t} else {\n\t\tbuffer = to.subarray(offset, offset + length);\n\t}\n\n\tconst result = textEncoder.encodeInto(str, buffer);\n\n\treturn result.written;\n};\n\nconst _fromCharCode = String.fromCharCode;\n\n// fully unrolled short string decoder, inspired by cbor-x\n// returns null if non-ASCII byte encountered, signaling fallback to TextDecoder\nconst _shortString = (from: Uint8Array, p: number, length: number): string | null => {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0) return '';\n\t\t\tconst a = from[p];\n\t\t\tif (a & 0x80) return null;\n\t\t\treturn _fromCharCode(a);\n\t\t}\n\t\tconst a = from[p];\n\t\tconst b = from[p + 1];\n\t\tif ((a | b) & 0x80) return null;\n\t\tif (length === 2) return _fromCharCode(a, b);\n\t\tconst c = from[p + 2];\n\t\tif (c & 0x80) return null;\n\t\treturn _fromCharCode(a, b, c);\n\t}\n\tconst a = from[p];\n\tconst b = from[p + 1];\n\tconst c = from[p + 2];\n\tconst d = from[p + 3];\n\tif ((a | b | c | d) & 0x80) return null;\n\tif (length < 8) {\n\t\tif (length === 4) return _fromCharCode(a, b, c, d);\n\t\tconst e = from[p + 4];\n\t\tif (e & 0x80) return null;\n\t\tif (length === 5) return _fromCharCode(a, b, c, d, e);\n\t\tconst f = from[p + 5];\n\t\tif (f & 0x80) return null;\n\t\tif (length === 6) return _fromCharCode(a, b, c, d, e, f);\n\t\tconst g = from[p + 6];\n\t\tif (g & 0x80) return null;\n\t\treturn _fromCharCode(a, b, c, d, e, f, g);\n\t}\n\tconst e = from[p + 4];\n\tconst f = from[p + 5];\n\tconst g = from[p + 6];\n\tconst h = from[p + 7];\n\tif ((e | f | g | h) & 0x80) return null;\n\tif (length < 12) {\n\t\tif (length === 8) return _fromCharCode(a, b, c, d, e, f, g, h);\n\t\tconst i = from[p + 8];\n\t\tif (i & 0x80) return null;\n\t\tif (length === 9) return _fromCharCode(a, b, c, d, e, f, g, h, i);\n\t\tconst j = from[p + 9];\n\t\tif (j & 0x80) return null;\n\t\tif (length === 10) return _fromCharCode(a, b, c, d, e, f, g, h, i, j);\n\t\tconst k = from[p + 10];\n\t\tif (k & 0x80) return null;\n\t\treturn _fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n\t}\n\tconst i = from[p + 8];\n\tconst j = from[p + 9];\n\tconst k = from[p + 10];\n\tconst l = from[p + 11];\n\tif ((i | j | k | l) & 0x80) return null;\n\tif (length === 12) return _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n\tconst m = from[p + 12];\n\tif (m & 0x80) return null;\n\tif (length === 13) return _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n\tconst n = from[p + 13];\n\tif (n & 0x80) return null;\n\tif (length === 14) return _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n\tconst o = from[p + 14];\n\tif (o & 0x80) return null;\n\treturn _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n};\n\n/**\n * decodes a UTF-8 string from a given buffer\n * @param from source buffer\n * @param offset byte offset to start reading from\n * @param length number of bytes to read\n * @returns decoded string\n */\nexport const decodeUtf8From = (\n\tfrom: Uint8Array,\n\toffset: number = 0,\n\tlength: number = from.length,\n): string => {\n\tif (length <= 15) {\n\t\tconst result = _shortString(from, offset, length);\n\t\tif (result !== null) return result;\n\t}\n\treturn textDecoder.decode(from.subarray(offset, offset + length));\n};\n\n/**\n * calculates the UTF-8 byte length of a string\n * @param str string to measure\n * @returns byte length when encoded as UTF-8\n */\nexport const getUtf8Length = (str: string): number => {\n\tconst len = str.length;\n\n\tlet u16pos = 0;\n\tlet u8pos = 0;\n\n\t// ASCII fast-path: batch process 4 chars at a time\n\twhile (u16pos + 3 < len) {\n\t\tconst a = str.charCodeAt(u16pos);\n\t\tconst b = str.charCodeAt(u16pos + 1);\n\t\tconst c = str.charCodeAt(u16pos + 2);\n\t\tconst d = str.charCodeAt(u16pos + 3);\n\n\t\tif ((a | b | c | d) >= 0x80) {\n\t\t\tbreak;\n\t\t}\n\n\t\tu16pos += 4;\n\t\tu8pos += 4;\n\t}\n\n\t// handle remaining chars\n\twhile (u16pos < len) {\n\t\tconst code = str.charCodeAt(u16pos);\n\n\t\tif (code < 0x80) {\n\t\t\tu16pos += 1;\n\t\t\tu8pos += 1;\n\t\t} else if (code < 0x800) {\n\t\t\tu16pos += 1;\n\t\t\tu8pos += 2;\n\t\t} else if (code < 0xd800 || code > 0xdbff) {\n\t\t\tu16pos += 1;\n\t\t\tu8pos += 3;\n\t\t} else {\n\t\t\tu16pos += 2;\n\t\t\tu8pos += 4;\n\t\t}\n\t}\n\n\treturn u8pos;\n};\n\n/**\n * get a SHA-256 digest of this buffer\n */\nexport const toSha256 = async (buffer: Uint8Array<ArrayBuffer>): Promise<Uint8Array<ArrayBuffer>> => {\n\treturn new Uint8Array(await subtle.digest('SHA-256', buffer));\n};\n", "import { alloc, allocUnsafe } from '@atcute/uint8array';\n\nexport const createRfc4648Encode = (alphabet: string, bitsPerChar: number, pad: boolean) => {\n\treturn (bytes: Uint8Array): string => {\n\t\tconst mask = (1 << bitsPerChar) - 1;\n\t\tlet str = '';\n\n\t\tlet bits = 0; // Number of bits currently in the buffer\n\t\tlet buffer = 0; // Bits waiting to be written out, MSB first\n\t\tfor (let i = 0; i < bytes.length; ++i) {\n\t\t\t// Slurp data into the buffer:\n\t\t\tbuffer = (buffer << 8) | bytes[i];\n\t\t\tbits += 8;\n\n\t\t\t// Write out as much as we can:\n\t\t\twhile (bits > bitsPerChar) {\n\t\t\t\tbits -= bitsPerChar;\n\t\t\t\tstr += alphabet[mask & (buffer >> bits)];\n\t\t\t}\n\t\t}\n\n\t\t// Partial character:\n\t\tif (bits !== 0) {\n\t\t\tstr += alphabet[mask & (buffer << (bitsPerChar - bits))];\n\t\t}\n\n\t\t// Add padding characters until we hit a byte boundary:\n\t\tif (pad) {\n\t\t\twhile (((str.length * bitsPerChar) & 7) !== 0) {\n\t\t\t\tstr += '=';\n\t\t\t}\n\t\t}\n\n\t\treturn str;\n\t};\n};\n\nexport const createRfc4648Decode = (alphabet: string, bitsPerChar: number, pad: boolean) => {\n\t// Build the character lookup table:\n\tconst codes: Record<string, number> = {};\n\tfor (let i = 0; i < alphabet.length; ++i) {\n\t\tcodes[alphabet[i]] = i;\n\t}\n\n\treturn (str: string): Uint8Array<ArrayBuffer> => {\n\t\t// Count the padding bytes:\n\t\tlet end = str.length;\n\t\twhile (pad && str[end - 1] === '=') {\n\t\t\t--end;\n\t\t}\n\n\t\t// Allocate the output:\n\t\tconst bytes = allocUnsafe(((end * bitsPerChar) / 8) | 0);\n\n\t\t// Parse the data:\n\t\tlet bits = 0; // Number of bits currently in the buffer\n\t\tlet buffer = 0; // Bits waiting to be written out, MSB first\n\t\tlet written = 0; // Next byte to write\n\t\tfor (let i = 0; i < end; ++i) {\n\t\t\t// Read one character from the string:\n\t\t\tconst value = codes[str[i]];\n\t\t\tif (value === undefined) {\n\t\t\t\tthrow new SyntaxError(`invalid base string`);\n\t\t\t}\n\n\t\t\t// Append the bits to the buffer:\n\t\t\tbuffer = (buffer << bitsPerChar) | value;\n\t\t\tbits += bitsPerChar;\n\n\t\t\t// Write out some bits if the buffer has a byte's worth:\n\t\t\tif (bits >= 8) {\n\t\t\t\tbits -= 8;\n\t\t\t\tbytes[written++] = 0xff & (buffer >> bits);\n\t\t\t}\n\t\t}\n\n\t\t// Verify that we have received just enough bits:\n\t\tif (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n\t\t\tthrow new SyntaxError('unexpected end of data');\n\t\t}\n\n\t\treturn bytes;\n\t};\n};\n\nexport const createBtcBaseEncode = (alphabet: string) => {\n\tif (alphabet.length >= 255) {\n\t\tthrow new RangeError(`alphabet too long`);\n\t}\n\n\tconst BASE = alphabet.length;\n\tconst LEADER = alphabet.charAt(0);\n\tconst iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n\n\treturn (source: Uint8Array): string => {\n\t\tif (source.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Skip & count leading zeroes.\n\t\tlet zeroes = 0;\n\t\tlet length = 0;\n\t\tlet pbegin = 0;\n\t\tconst pend = source.length;\n\t\twhile (pbegin !== pend && source[pbegin] === 0) {\n\t\t\tpbegin++;\n\t\t\tzeroes++;\n\t\t}\n\n\t\t// Allocate enough space in big-endian base58 representation.\n\t\tconst size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n\t\tconst b58 = alloc(size);\n\n\t\t// Process the bytes.\n\t\twhile (pbegin !== pend) {\n\t\t\tlet carry = source[pbegin];\n\n\t\t\t// Apply \"b58 = b58 * 256 + ch\".\n\t\t\tlet i = 0;\n\t\t\tfor (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n\t\t\t\tcarry += (256 * b58[it1]) >>> 0;\n\t\t\t\tb58[it1] = carry % BASE >>> 0;\n\t\t\t\tcarry = (carry / BASE) >>> 0;\n\t\t\t}\n\n\t\t\tif (carry !== 0) {\n\t\t\t\tthrow new Error('non-zero carry');\n\t\t\t}\n\n\t\t\tlength = i;\n\t\t\tpbegin++;\n\t\t}\n\n\t\t// Skip leading zeroes in base58 result.\n\t\tlet it2 = size - length;\n\t\twhile (it2 !== size && b58[it2] === 0) {\n\t\t\tit2++;\n\t\t}\n\n\t\t// Translate the result into a string.\n\t\tlet str = LEADER.repeat(zeroes);\n\t\tfor (; it2 < size; ++it2) {\n\t\t\tstr += alphabet.charAt(b58[it2]);\n\t\t}\n\n\t\treturn str;\n\t};\n};\n\nexport const createBtcBaseDecode = (alphabet: string) => {\n\tif (alphabet.length >= 255) {\n\t\tthrow new RangeError(`alphabet too long`);\n\t}\n\n\tconst BASE_MAP = allocUnsafe(256).fill(255);\n\tfor (let i = 0; i < alphabet.length; i++) {\n\t\tconst xc = alphabet.charCodeAt(i);\n\n\t\tif (BASE_MAP[xc] !== 255) {\n\t\t\tthrow new RangeError(`${alphabet[i]} is ambiguous`);\n\t\t}\n\n\t\tBASE_MAP[xc] = i;\n\t}\n\n\tconst BASE = alphabet.length;\n\tconst LEADER = alphabet.charAt(0);\n\tconst FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n\n\treturn (source: string): Uint8Array<ArrayBuffer> => {\n\t\tif (source.length === 0) {\n\t\t\treturn allocUnsafe(0);\n\t\t}\n\n\t\t// Skip and count leading '1's.\n\t\tlet psz = 0;\n\t\tlet zeroes = 0;\n\t\tlet length = 0;\n\n\t\twhile (source[psz] === LEADER) {\n\t\t\tzeroes++;\n\t\t\tpsz++;\n\t\t}\n\n\t\t// Allocate enough space in big-endian base256 representation.\n\t\tconst size = ((source.length - psz) * FACTOR + 1) >>> 0; // log(58) / log(256), rounded up.\n\t\tconst b256 = alloc(size);\n\n\t\t// Process the characters.\n\t\twhile (psz < source.length) {\n\t\t\t// Decode character\n\t\t\tlet carry = BASE_MAP[source.charCodeAt(psz)];\n\n\t\t\t// Invalid character\n\t\t\tif (carry === 255) {\n\t\t\t\tthrow new Error(`invalid string`);\n\t\t\t}\n\n\t\t\tlet i = 0;\n\t\t\tfor (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n\t\t\t\tcarry += (BASE * b256[it3]) >>> 0;\n\t\t\t\tb256[it3] = carry % 256 >>> 0;\n\t\t\t\tcarry = (carry / 256) >>> 0;\n\t\t\t}\n\t\t\tif (carry !== 0) {\n\t\t\t\tthrow new Error('non-zero carry');\n\t\t\t}\n\t\t\tlength = i;\n\t\t\tpsz++;\n\t\t}\n\n\t\t// Skip leading zeroes in b256.\n\t\tlet it4 = size - length;\n\t\twhile (it4 !== size && b256[it4] === 0) {\n\t\t\tit4++;\n\t\t}\n\n\t\tif (it4 === zeroes) {\n\t\t\treturn b256;\n\t\t}\n\n\t\tconst vch = allocUnsafe(zeroes + (size - it4));\n\t\tvch.fill(0, 0, zeroes);\n\t\tvch.set(b256.subarray(it4), zeroes);\n\n\t\treturn vch;\n\t};\n};\n", "// #region base64\nexport const fromBase64 = (str: string): Uint8Array<ArrayBuffer> => {\n\treturn Uint8Array.fromBase64(str, { alphabet: 'base64', lastChunkHandling: 'loose' }) as Uint8Array<ArrayBuffer>;\n};\n\nexport const toBase64 = (bytes: Uint8Array): string => {\n\treturn bytes.toBase64({ alphabet: 'base64', omitPadding: true });\n};\n// #endregion\n\n// #region base64pad\nexport const fromBase64Pad = (str: string): Uint8Array<ArrayBuffer> => {\n\treturn Uint8Array.fromBase64(str, { alphabet: 'base64', lastChunkHandling: 'strict' }) as Uint8Array<ArrayBuffer>;\n};\n\nexport const toBase64Pad = (bytes: Uint8Array): string => {\n\treturn bytes.toBase64({ alphabet: 'base64', omitPadding: false });\n};\n// #endregion\n\n// #region base64url\nexport const fromBase64Url = (str: string): Uint8Array<ArrayBuffer> => {\n\treturn Uint8Array.fromBase64(str, { alphabet: 'base64url', lastChunkHandling: 'loose' }) as Uint8Array<ArrayBuffer>;\n};\n\nexport const toBase64Url = (bytes: Uint8Array): string => {\n\treturn bytes.toBase64({ alphabet: 'base64url', omitPadding: true });\n};\n// #endregion\n\n// #region base64urlpad\nexport const fromBase64UrlPad = (str: string): Uint8Array<ArrayBuffer> => {\n\treturn Uint8Array.fromBase64(str, { alphabet: 'base64url', lastChunkHandling: 'strict' }) as Uint8Array<ArrayBuffer>;\n};\n\nexport const toBase64UrlPad = (bytes: Uint8Array): string => {\n\treturn bytes.toBase64({ alphabet: 'base64url', omitPadding: false });\n};\n// #endregion\n", "import { createRfc4648Decode, createRfc4648Encode } from '../utils.js';\n\nconst BASE64_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst BASE64URL_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n// #region base64\nexport const fromBase64: (str: string) => Uint8Array<ArrayBuffer> = /*#__PURE__*/ createRfc4648Decode(\n\tBASE64_CHARSET,\n\t6,\n\tfalse,\n);\nexport const toBase64: (bytes: Uint8Array) => string = /*#__PURE__*/ createRfc4648Encode(\n\tBASE64_CHARSET,\n\t6,\n\tfalse,\n);\n// #endregion\n\n// #region base64pad\nexport const fromBase64Pad: (str: string) => Uint8Array<ArrayBuffer> = /*#__PURE__*/ createRfc4648Decode(\n\tBASE64_CHARSET,\n\t6,\n\ttrue,\n);\nexport const toBase64Pad: (bytes: Uint8Array) => string = /*#__PURE__*/ createRfc4648Encode(\n\tBASE64_CHARSET,\n\t6,\n\ttrue,\n);\n// #endregion\n\n// #region base64url\nexport const fromBase64Url: (str: string) => Uint8Array<ArrayBuffer> = /*#__PURE__*/ createRfc4648Decode(\n\tBASE64URL_CHARSET,\n\t6,\n\tfalse,\n);\nexport const toBase64Url: (bytes: Uint8Array) => string = /*#__PURE__*/ createRfc4648Encode(\n\tBASE64URL_CHARSET,\n\t6,\n\tfalse,\n);\n// #endregion\n\n// #region base64urlpad\nexport const fromBase64UrlPad: (str: string) => Uint8Array<ArrayBuffer> = /*#__PURE__*/ createRfc4648Decode(\n\tBASE64URL_CHARSET,\n\t6,\n\ttrue,\n);\nexport const toBase64UrlPad: (bytes: Uint8Array) => string = /*#__PURE__*/ createRfc4648Encode(\n\tBASE64URL_CHARSET,\n\t6,\n\ttrue,\n);\n// #endregion\n", "import {\n\tfromBase64 as fromBase64Native,\n\tfromBase64Pad as fromBase64PadNative,\n\tfromBase64Url as fromBase64UrlNative,\n\tfromBase64UrlPad as fromBase64UrlPadNative,\n\ttoBase64 as toBase64Native,\n\ttoBase64Pad as toBase64PadNative,\n\ttoBase64Url as toBase64UrlNative,\n\ttoBase64UrlPad as toBase64UrlPadNative,\n} from './base64-web-native.js';\nimport {\n\tfromBase64Pad as fromBase64PadPolyfill,\n\tfromBase64 as fromBase64Polyfill,\n\tfromBase64UrlPad as fromBase64UrlPadPolyfill,\n\tfromBase64Url as fromBase64UrlPolyfill,\n\ttoBase64Pad as toBase64PadPolyfill,\n\ttoBase64 as toBase64Polyfill,\n\ttoBase64UrlPad as toBase64UrlPadPolyfill,\n\ttoBase64Url as toBase64UrlPolyfill,\n} from './base64-web-polyfill.js';\n\nconst HAS_NATIVE_SUPPORT = 'fromBase64' in Uint8Array;\n\n// #region base64\nexport const fromBase64 = !HAS_NATIVE_SUPPORT ? fromBase64Polyfill : fromBase64Native;\nexport const toBase64 = !HAS_NATIVE_SUPPORT ? toBase64Polyfill : toBase64Native;\n// #endregion\n\n// #region base64pad\nexport const fromBase64Pad = !HAS_NATIVE_SUPPORT ? fromBase64PadPolyfill : fromBase64PadNative;\nexport const toBase64Pad = !HAS_NATIVE_SUPPORT ? toBase64PadPolyfill : toBase64PadNative;\n// #endregion\n\n// #region base64url\nexport const fromBase64Url = !HAS_NATIVE_SUPPORT ? fromBase64UrlPolyfill : fromBase64UrlNative;\nexport const toBase64Url = !HAS_NATIVE_SUPPORT ? toBase64UrlPolyfill : toBase64UrlNative;\n// #endregion\n\n// #region base64urlpad\nexport const fromBase64UrlPad = !HAS_NATIVE_SUPPORT ? fromBase64UrlPadPolyfill : fromBase64UrlPadNative;\nexport const toBase64UrlPad = !HAS_NATIVE_SUPPORT ? toBase64UrlPadPolyfill : toBase64UrlPadNative;\n// #endregion\n", "import { createRfc4648Decode, createRfc4648Encode } from '../utils.js';\n\nconst BASE32_CHARSET = 'abcdefghijklmnopqrstuvwxyz234567';\n\nexport const fromBase32: (source: string) => Uint8Array<ArrayBuffer> = /*#__PURE__*/ createRfc4648Decode(\n\tBASE32_CHARSET,\n\t5,\n\tfalse,\n);\n\nexport const toBase32: (source: Uint8Array) => string = /*#__PURE__*/ createRfc4648Encode(\n\tBASE32_CHARSET,\n\t5,\n\tfalse,\n);\n", "import { fromBase32, toBase32 } from '@atcute/multibase';\nimport { allocUnsafe, toSha256, equals as isBufferEqual } from '@atcute/uint8array';\n\n/** CID version, always `1` for CIDv1 */\nexport const CID_VERSION = 1;\n/** multicodec for SHA-256 hash */\nexport const HASH_SHA256 = 0x12;\n\n/** multicodec for raw binary data */\nexport const CODEC_RAW = 0x55;\n/** multicodec for DAG-CBOR encoded data */\nexport const CODEC_DCBOR = 0x71;\n\n/** @internal */\nexport const CID_STRINGIFY_CACHE = new WeakMap<Cid, string>();\n\n/**\n * Represents a Content Identifier (CID), in particular, a limited subset of\n * CIDv1 as described by DASL specifications.\n * https://dasl.ing/cid.html\n */\nexport interface Cid {\n\t/** CID version, this is always `1` for CIDv1 */\n\treadonly version: number;\n\t/** Multicodec type for the data, can be `0x55` for raw data or `0x71` for DAG-CBOR */\n\treadonly codec: number;\n\t/** Digest contents */\n\treadonly digest: {\n\t\t/** Multicodec type for the digest, this is always `0x12` for SHA-256 */\n\t\treadonly codec: number;\n\t\t/** Raw hash bytes */\n\t\treadonly contents: Uint8Array;\n\t};\n\t/** Raw CID bytes */\n\treadonly bytes: Uint8Array;\n}\n\n// a SHA-256 CIDv1 is always going to be 36 bytes, that's 4 bytes for the\n// header, and 32 bytes for the digest itself.\n\n/**\n * creates a CID from a pre-computed SHA-256 digest\n * @param codec multicodec type for the data\n * @param digest raw SHA-256 hash bytes (must be 32 bytes)\n * @returns CID object\n */\nexport const fromDigest = (codec: 0x55 | 0x71, digest: Uint8Array): Cid => {\n\tif (digest.length !== 32) {\n\t\tthrow new RangeError(`invalid digest length`);\n\t}\n\n\tconst bytes = allocUnsafe(4 + 32);\n\n\tbytes[0] = CID_VERSION;\n\tbytes[1] = codec;\n\tbytes[2] = HASH_SHA256;\n\tbytes[3] = 32;\n\n\tbytes.set(digest, 4);\n\n\treturn {\n\t\tversion: CID_VERSION,\n\t\tcodec: codec,\n\t\tdigest: {\n\t\t\tcodec: HASH_SHA256,\n\t\t\tcontents: bytes.subarray(4, 36),\n\t\t},\n\t\tbytes: bytes,\n\t};\n};\n\n/**\n * creates a CID by hashing the provided data with SHA-256\n * @param codec multicodec type for the data\n * @param data raw data to hash\n * @returns CID object\n */\nexport const create = async (codec: 0x55 | 0x71, data: Uint8Array): Promise<Cid> => {\n\tconst digest = await toSha256(data);\n\treturn fromDigest(codec, digest);\n};\n\n/**\n * creates an empty CID with a zero-length digest\n * @param codec multicodec type for the data\n * @returns CID object with empty digest\n */\nexport const createEmpty = (codec: 0x55 | 0x71): Cid => {\n\tconst bytes = Uint8Array.from([CID_VERSION, codec, HASH_SHA256, 0]);\n\tconst digest = bytes.subarray(4);\n\n\tconst cid: Cid = {\n\t\tversion: CID_VERSION,\n\t\tcodec: codec,\n\t\tdigest: {\n\t\t\tcodec: HASH_SHA256,\n\t\t\tcontents: digest,\n\t\t},\n\t\tbytes: bytes,\n\t};\n\n\treturn cid;\n};\n\n/**\n * decodes a CID from bytes, returning the CID and any remaining bytes\n * @param bytes raw CID bytes\n * @returns tuple of decoded CID and remainder bytes\n * @throws {RangeError} if the bytes are too short or contain invalid values\n */\nexport const decodeFirst = (bytes: Uint8Array): [decoded: Cid, remainder: Uint8Array] => {\n\tconst length = bytes.length;\n\n\tif (length < 4) {\n\t\tthrow new RangeError(`cid too short`);\n\t}\n\n\tconst version = bytes[0];\n\tconst codec = bytes[1];\n\tconst digestType = bytes[2];\n\tconst digestSize = bytes[3];\n\n\tif (version !== CID_VERSION) {\n\t\tthrow new RangeError(`incorrect cid version (got v${version})`);\n\t}\n\n\tif (codec !== CODEC_DCBOR && codec !== CODEC_RAW) {\n\t\tthrow new RangeError(`incorrect cid codec (got 0x${codec.toString(16)})`);\n\t}\n\n\tif (digestType !== HASH_SHA256) {\n\t\tthrow new RangeError(`incorrect cid digest codec (got 0x${digestType.toString(16)})`);\n\t}\n\n\tif (digestSize !== 32 && digestSize !== 0) {\n\t\tthrow new RangeError(`incorrect cid digest size (got ${digestSize})`);\n\t}\n\n\tif (length < 4 + digestSize) {\n\t\tthrow new RangeError(`cid too short`);\n\t}\n\n\tconst cid: Cid = {\n\t\tversion: CID_VERSION,\n\t\tcodec: codec,\n\t\tdigest: {\n\t\t\tcodec: digestType,\n\t\t\tcontents: bytes.subarray(4, 4 + digestSize),\n\t\t},\n\t\tbytes: bytes.subarray(0, 4 + digestSize),\n\t};\n\n\treturn [cid, bytes.subarray(4 + digestSize)];\n};\n\n/**\n * decodes a CID from bytes, expecting no remainder\n * @param bytes raw CID bytes\n * @returns decoded CID\n * @throws {RangeError} if the bytes are invalid or contain extra data\n */\nexport const decode = (bytes: Uint8Array): Cid => {\n\tconst [cid, remainder] = decodeFirst(bytes);\n\n\tif (remainder.length !== 0) {\n\t\tthrow new RangeError(`cid bytes includes remainder`);\n\t}\n\n\treturn cid;\n};\n\n/**\n * parses a CID from a multibase base32 string\n * @param input base32-encoded CID string (with 'b' prefix)\n * @returns decoded CID\n * @throws {SyntaxError} if the string is not a valid multibase base32 string\n * @throws {RangeError} if the string length is invalid\n */\nexport const fromString = (input: string): Cid => {\n\tif (input.length < 2 || input[0] !== 'b') {\n\t\tthrow new SyntaxError(`not a multibase base32 string`);\n\t}\n\n\t// 4 bytes in base32 = 7 characters + 1 character for the prefix\n\t// 36 bytes in base32 = 58 characters + 1 character for the prefix\n\tif (input.length !== 59 && input.length !== 8) {\n\t\tthrow new RangeError(`cid too short`);\n\t}\n\n\tconst bytes = fromBase32(input.slice(1));\n\tconst cid = decode(bytes);\n\n\tCID_STRINGIFY_CACHE.set(cid, input);\n\treturn cid;\n};\n\n/**\n * encodes a CID to a multibase base32 string\n * @param cid CID to encode\n * @returns base32-encoded string with 'b' prefix\n */\nexport const toString = (cid: Cid): string => {\n\tlet str = CID_STRINGIFY_CACHE.get(cid);\n\tif (str === undefined) {\n\t\tstr = `b${toBase32(cid.bytes)}`;\n\n\t\tCID_STRINGIFY_CACHE.set(cid, str);\n\t}\n\n\treturn str;\n};\n\n/**\n * parses a CID from binary format (with 0x00 prefix)\n * @param input binary CID bytes with 0x00 prefix\n * @returns decoded CID\n * @throws {RangeError} if the byte length is invalid\n * @throws {SyntaxError} if the prefix byte is not 0x00\n */\nexport const fromBinary = (input: Uint8Array): Cid => {\n\t// 4 bytes + 1 byte for the 0x00 prefix\n\t// 36 bytes + 1 byte for the 0x00 prefix\n\tif (input.length !== 37 && input.length !== 5) {\n\t\tthrow new RangeError(`cid bytes too short`);\n\t}\n\n\tif (input[0] !== 0) {\n\t\tthrow new SyntaxError(`incorrect binary cid`);\n\t}\n\n\tconst bytes = input.subarray(1);\n\treturn decode(bytes);\n};\n\n/**\n * encodes a CID to binary format (with 0x00 prefix)\n * @param cid CID to encode\n * @returns binary CID bytes with 0x00 prefix\n */\nexport const toBinary = (cid: Cid): Uint8Array => {\n\tconst bytes = allocUnsafe(1 + cid.bytes.length);\n\tbytes[0] = 0;\n\tbytes.set(cid.bytes, 1);\n\n\treturn bytes;\n};\n\n/**\n * checks if two CIDs are equal\n * @param a first CID\n * @param b second CID\n * @returns true if the CIDs have identical bytes\n */\nexport const equals = (a: Cid, b: Cid): boolean => {\n\treturn isBufferEqual(a.bytes, b.bytes);\n};\n", "import { toBase32 } from '@atcute/multibase';\n\nimport { CID_STRINGIFY_CACHE, decode, fromString, type Cid } from './codec.js';\n\nconst CID_LINK_SYMBOL = Symbol.for('@atcute/cid-link-wrapper');\n\n/** @internal */\nexport const CIDLINK_STRINGIFY_CACHE = new WeakMap<CidLinkWrapper, string>();\n\nexport interface CidLink {\n\t$link: string;\n}\n\nexport class CidLinkWrapper implements CidLink {\n\t/** @internal */\n\treadonly [CID_LINK_SYMBOL] = true;\n\n\treadonly bytes: Uint8Array;\n\n\tconstructor(bytes: Uint8Array) {\n\t\tthis.bytes = bytes;\n\t}\n\n\tget $link(): string {\n\t\tlet str = CIDLINK_STRINGIFY_CACHE.get(this);\n\t\tif (str === undefined) {\n\t\t\tstr = `b${toBase32(this.bytes)}`;\n\n\t\t\tCIDLINK_STRINGIFY_CACHE.set(this, str);\n\t\t}\n\n\t\treturn str;\n\t}\n\n\ttoJSON(): CidLink {\n\t\treturn { $link: this.$link };\n\t}\n}\n\nexport const isCidLink = (value: unknown): value is CidLink => {\n\tconst val = value as any;\n\n\treturn (\n\t\tval instanceof CidLinkWrapper ||\n\t\t(val !== null && typeof val === 'object' && typeof val.$link === 'string')\n\t);\n};\n\nexport const toCidLink = (cid: Cid): CidLink => {\n\tconst inst = new CidLinkWrapper(cid.bytes);\n\tconst str = CID_STRINGIFY_CACHE.get(cid);\n\n\tif (str !== undefined) {\n\t\tCIDLINK_STRINGIFY_CACHE.set(inst, str);\n\t}\n\n\treturn inst;\n};\n\nexport const fromCidLink = (link: CidLink): Cid => {\n\tif (link instanceof CidLinkWrapper) {\n\t\treturn decode(link.bytes);\n\t}\n\n\treturn fromString(link.$link);\n};\n", "import { fromBase64, toBase64 } from '@atcute/multibase';\n\nexport interface Bytes {\n\t$bytes: string;\n}\n\nconst BYTES_SYMBOL = Symbol.for('@atcute/bytes-wrapper');\n\nexport class BytesWrapper implements Bytes {\n\t/** @internal */\n\treadonly [BYTES_SYMBOL] = true;\n\n\tconstructor(public buf: Uint8Array) {}\n\n\tget $bytes(): string {\n\t\treturn toBase64(this.buf);\n\t}\n\n\ttoJSON(): Bytes {\n\t\treturn { $bytes: this.$bytes };\n\t}\n}\n\nexport const isBytes = (value: unknown): value is Bytes => {\n\tconst val = value as any;\n\n\treturn (\n\t\tval instanceof BytesWrapper || (val !== null && typeof val === 'object' && typeof val.$bytes === 'string')\n\t);\n};\n\nexport const toBytes = (buf: Uint8Array): Bytes => {\n\treturn new BytesWrapper(buf);\n};\n\nexport const fromBytes = (bytes: Bytes): Uint8Array => {\n\tif (bytes instanceof BytesWrapper) {\n\t\treturn bytes.buf;\n\t}\n\n\treturn fromBase64(bytes.$bytes);\n};\n", "import { CidLinkWrapper, fromBinary, type CidLink } from '@atcute/cid';\nimport { decodeUtf8From } from '@atcute/uint8array';\n\nimport { toBytes, type Bytes } from './bytes.js';\n\ninterface State {\n\tb: Uint8Array;\n\tv: DataView | null;\n\tp: number;\n}\n\nconst readArgument = (state: State, info: number): number => {\n\tif (info < 24) {\n\t\treturn info;\n\t}\n\n\tlet arg: number;\n\tswitch (info) {\n\t\tcase 24: {\n\t\t\targ = readUint8(state);\n\t\t\tif (arg < 24) {\n\t\t\t\tthrow new TypeError(`non-canonical argument encoding`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 25: {\n\t\t\targ = readUint16(state);\n\t\t\tif (arg < 0x100) {\n\t\t\t\tthrow new TypeError(`non-canonical argument encoding`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 26: {\n\t\t\targ = readUint32(state);\n\t\t\tif (arg < 0x10000) {\n\t\t\t\tthrow new TypeError(`non-canonical argument encoding`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 27: {\n\t\t\targ = readUint53(state);\n\t\t\tif (arg < 0x100000000) {\n\t\t\t\tthrow new TypeError(`non-canonical argument encoding`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new Error(`invalid argument encoding; got ${info}`);\n\t\t}\n\t}\n\treturn arg;\n};\n\nconst readFloat64 = (state: State): number => {\n\tconst view = (state.v ??= new DataView(state.b.buffer, state.b.byteOffset, state.b.byteLength));\n\tconst value = view.getFloat64(state.p);\n\n\tstate.p += 8;\n\treturn value;\n};\n\nconst readUint8 = (state: State): number => {\n\treturn state.b[state.p++];\n};\n\nconst readUint16 = (state: State): number => {\n\tlet pos = state.p;\n\n\tconst buf = state.b;\n\tconst value = (buf[pos++] << 8) | buf[pos++];\n\n\tstate.p = pos;\n\treturn value;\n};\n\nconst readUint32 = (state: State): number => {\n\tlet pos = state.p;\n\n\tconst buf = state.b;\n\tconst value = ((buf[pos++] << 24) | (buf[pos++] << 16) | (buf[pos++] << 8) | buf[pos++]) >>> 0;\n\n\tstate.p = pos;\n\treturn value;\n};\n\nconst readUint53 = (state: State): number => {\n\tconst hi = readUint32(state);\n\tconst lo = readUint32(state);\n\n\tif (hi > 0x1fffff) {\n\t\tthrow new RangeError(`can't decode integers beyond safe integer range`);\n\t}\n\n\treturn hi * 2 ** 32 + lo;\n};\n\nconst readString = (state: State, length: number): string => {\n\tconst string = decodeUtf8From(state.b, state.p, length);\n\tstate.p += length;\n\n\treturn string;\n};\n\nconst readBytes = (state: State, length: number): Bytes => {\n\tconst slice = state.b.subarray(state.p, (state.p += length));\n\n\treturn toBytes(slice);\n};\n\nconst readCid = (state: State, length: number): CidLink => {\n\tconst cid = fromBinary(state.b.subarray(state.p, (state.p += length)));\n\n\treturn new CidLinkWrapper(cid.bytes);\n};\n\nconst compareKeys = (a: string, b: string): number => {\n\treturn a.length - b.length || (a < b ? -1 : a > b ? 1 : 0);\n};\n\nconst decodeStringKey = (state: State): string => {\n\tconst prelude = readUint8(state);\n\n\tconst type = prelude >> 5;\n\tif (type !== 3) {\n\t\tthrow new TypeError(`expected map to only have string keys; got type ${type}`);\n\t}\n\n\tconst info = prelude & 0x1f;\n\tconst length = readArgument(state, info);\n\treturn readString(state, length);\n};\n\ntype Container =\n\t| {\n\t\t\t/** map type */\n\t\t\tt: 0;\n\t\t\t/** container value */\n\t\t\tc: Record<string, unknown>;\n\t\t\t/** held key (as we decode the value) */\n\t\t\tk: string;\n\t\t\t/** remaining elements (key + value) */\n\t\t\tr: number;\n\t\t\t/** next container in stack */\n\t\t\tn: Container | null;\n\t  }\n\t| {\n\t\t\t/** array type */\n\t\t\tt: 1;\n\t\t\t/** container value */\n\t\t\tc: any[];\n\t\t\t/** held key (not used) */\n\t\t\tk: null;\n\t\t\t/** remaining elements (values) */\n\t\t\tr: number;\n\t\t\t/** next container in stack */\n\t\t\tn: Container | null;\n\t  };\n\nexport const decodeFirst = (buf: Uint8Array): [value: any, remainder: Uint8Array] => {\n\tconst len = buf.length;\n\n\tconst state: State = {\n\t\tb: buf,\n\t\tv: null,\n\t\tp: 0,\n\t};\n\n\tlet stack: Container | null = null;\n\tlet value: any;\n\n\tjump: while (state.p < len) {\n\t\tconst prelude = readUint8(state);\n\n\t\tconst type = prelude >> 5;\n\t\tconst info = prelude & 0x1f;\n\t\tconst arg = type === 7 ? 0 : readArgument(state, info);\n\n\t\tswitch (type) {\n\t\t\tcase 0: {\n\t\t\t\tvalue = arg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tvalue = -1 - arg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tvalue = readBytes(state, arg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tvalue = readString(state, arg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tif (arg > 0) {\n\t\t\t\t\tstack = { t: 1, c: (value = new Array(arg)), k: null, r: arg, n: stack };\n\t\t\t\t\tcontinue jump;\n\t\t\t\t}\n\n\t\t\t\tvalue = [];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 5: {\n\t\t\t\tvalue = {};\n\t\t\t\tif (arg > 0) {\n\t\t\t\t\t// We'll read the key of the first item here.\n\t\t\t\t\tconst first = decodeStringKey(state);\n\n\t\t\t\t\tstack = { t: 0, c: value, k: first, r: arg, n: stack };\n\t\t\t\t\tcontinue jump;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 6: {\n\t\t\t\tswitch (arg) {\n\t\t\t\t\tcase 42: {\n\t\t\t\t\t\tconst prelude = readUint8(state);\n\n\t\t\t\t\t\tconst type = prelude >> 5;\n\t\t\t\t\t\tconst info = prelude & 0x1f;\n\t\t\t\t\t\tif (type !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError(`expected cid-link to be type 2 (bytes); got type ${type}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst len = readArgument(state, info);\n\t\t\t\t\t\tvalue = readCid(state, len);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tthrow new TypeError(`unsupported tag; got ${arg}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 7: {\n\t\t\t\tswitch (info) {\n\t\t\t\t\tcase 20:\n\t\t\t\t\tcase 21: {\n\t\t\t\t\t\tvalue = info === 21;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 22: {\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 27: {\n\t\t\t\t\t\tvalue = readFloat64(state);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tthrow new Error(`invalid simple value; got ${info}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new TypeError(`invalid type; got ${type}`);\n\t\t\t}\n\t\t}\n\n\t\twhile (stack !== null) {\n\t\t\tswitch (stack.t) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tconst obj = stack.c;\n\t\t\t\t\tconst key = stack.k;\n\n\t\t\t\t\tif (key === '__proto__') {\n\t\t\t\t\t\t// Guard against prototype pollution. CWE-1321\n\t\t\t\t\t\tObject.defineProperty(obj, key, { enumerable: true, configurable: true, writable: true });\n\t\t\t\t\t}\n\n\t\t\t\t\tobj[key] = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tconst arr = stack.c;\n\t\t\t\t\tconst index = arr.length - stack.r;\n\n\t\t\t\t\tarr[index] = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (--stack.r) {\n\t\t\t\t// We still have more values to decode, continue\n\n\t\t\t\tif (!stack.t) {\n\t\t\t\t\t// Read the key of the next map item\n\t\t\t\t\tconst prevKey = stack.k;\n\t\t\t\t\tstack.k = decodeStringKey(state);\n\n\t\t\t\t\tif (compareKeys(stack.k, prevKey) <= 0) {\n\t\t\t\t\t\tthrow new TypeError(`map keys are not in canonical order or contain duplicates`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue jump;\n\t\t\t}\n\n\t\t\t// Unwrap the stack\n\t\t\tvalue = stack.c;\n\t\t\tstack = stack.n;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn [value, buf.subarray(state.p)];\n};\n\nexport const decode = (buf: Uint8Array): any => {\n\tconst [value, remainder] = decodeFirst(buf);\n\tif (remainder.length !== 0) {\n\t\tthrow new Error(`decoded value contains remainder`);\n\t}\n\n\treturn value;\n};\n", "const MSB = 0x80;\nconst REST = 0x7f;\nconst MSBALL = ~REST;\nconst INT = 2 ** 31;\n\nconst N1 = 2 ** 7;\nconst N2 = 2 ** 14;\nconst N3 = 2 ** 21;\nconst N4 = 2 ** 28;\nconst N5 = 2 ** 35;\nconst N6 = 2 ** 42;\nconst N7 = 2 ** 49;\nconst N8 = 2 ** 56;\nconst N9 = 2 ** 63;\n\n/**\n * Encodes a varint\n * @param num Number to encode\n * @param buf Buffer to write on\n * @param offset Starting position on the buffer\n * @returns The amount of bytes written\n */\nexport const encode = (num: number, buf: Uint8Array | number[], offset = 0): number => {\n\tif (num > Number.MAX_SAFE_INTEGER) {\n\t\tthrow new RangeError('could not encode varint');\n\t}\n\n\tconst start = offset;\n\n\twhile (num >= INT) {\n\t\tbuf[offset++] = (num & 0xff) | MSB;\n\t\tnum /= 128;\n\t}\n\n\twhile (num & MSBALL) {\n\t\tbuf[offset++] = (num & 0xff) | MSB;\n\t\tnum >>>= 7;\n\t}\n\n\tbuf[offset] = num | 0;\n\treturn offset - start + 1;\n};\n\n/**\n * Decodes a varint\n * @param buf Buffer to read from\n * @param offset Starting position on the buffer\n * @returns A tuple containing the resulting number, and the amount of bytes read\n */\nexport const decode = (buf: Uint8Array | number[], offset = 0): [num: number, read: number] => {\n\t// deno-lint-ignore prefer-const\n\tlet l = buf.length;\n\n\tlet res = 0;\n\tlet shift = 0;\n\tlet counter = offset;\n\tlet b: number;\n\n\tdo {\n\t\tif (counter >= l) {\n\t\t\tthrow new RangeError('could not decode varint');\n\t\t}\n\n\t\tb = buf[counter++];\n\t\tres += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);\n\t\tshift += 7;\n\t} while (b >= MSB);\n\n\treturn [res, counter - offset];\n};\n\n/**\n * Returns encoding length\n * @param num The number to encode\n * @returns Amount of bytes needed for encoding\n */\nexport const encodingLength = (num: number): number => {\n\treturn num < N1\n\t\t? 1\n\t\t: num < N2\n\t\t\t? 2\n\t\t\t: num < N3\n\t\t\t\t? 3\n\t\t\t\t: num < N4\n\t\t\t\t\t? 4\n\t\t\t\t\t: num < N5\n\t\t\t\t\t\t? 5\n\t\t\t\t\t\t: num < N6\n\t\t\t\t\t\t\t? 6\n\t\t\t\t\t\t\t: num < N7\n\t\t\t\t\t\t\t\t? 7\n\t\t\t\t\t\t\t\t: num < N8\n\t\t\t\t\t\t\t\t\t? 8\n\t\t\t\t\t\t\t\t\t: num < N9\n\t\t\t\t\t\t\t\t\t\t? 9\n\t\t\t\t\t\t\t\t\t\t: 10;\n};\n", "import { CidLinkWrapper, type Cid, type CidLink } from '@atcute/cid';\n\nexport interface CarV1Header {\n\tversion: 1;\n\troots: CidLink[];\n}\n\nexport const isCarV1Header = (value: unknown): value is CarV1Header => {\n\tif (value === null || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst { version, roots } = value as CarV1Header;\n\treturn version === 1 && Array.isArray(roots) && roots.every((root) => root instanceof CidLinkWrapper);\n};\n\nexport interface CarHeader {\n\theaderStart: number;\n\theaderEnd: number;\n\n\tdata: CarV1Header;\n\tdataStart: number;\n\tdataEnd: number;\n}\n\nexport interface CarEntry {\n\tentryStart: number;\n\tentryEnd: number;\n\n\tcid: Cid;\n\tcidStart: number;\n\tcidEnd: number;\n\n\tbytes: Uint8Array;\n\tbytesStart: number;\n\tbytesEnd: number;\n}\n\n/**\n * represents a block to be written to a CAR file\n */\nexport interface CarBlock {\n\t/** the CID of the block (as bytes) */\n\tcid: Uint8Array;\n\t/** the block data */\n\tdata: Uint8Array;\n}", "import * as CBOR from '@atcute/cbor';\nimport type { CidLink } from '@atcute/cid';\nimport * as CID from '@atcute/cid';\nimport * as varint from '@atcute/varint';\n\nimport { isCarV1Header, type CarEntry, type CarHeader } from './types.js';\n\ninterface SyncByteReader {\n\treadonly pos: number;\n\tupto(size: number): Uint8Array;\n\texactly(size: number, seek: boolean): Uint8Array;\n\tseek(size: number): void;\n}\n\nexport interface SyncCarReader {\n\treadonly header: CarHeader;\n\treadonly roots: CidLink[];\n\n\t/** @deprecated do for..of on the reader directly */\n\titerate(): Generator<CarEntry>;\n\t[Symbol.iterator](): Iterator<CarEntry>;\n}\n\nexport const fromUint8Array = (buffer: Uint8Array): SyncCarReader => {\n\tconst reader = createUint8Reader(buffer);\n\tconst header = readHeader(reader);\n\n\treturn {\n\t\theader,\n\t\troots: header.data.roots,\n\n\t\t*iterate() {\n\t\t\twhile (reader.upto(8 + 36).length > 0) {\n\t\t\t\tconst entryStart = reader.pos;\n\t\t\t\tconst entrySize = readVarint(reader, 8);\n\n\t\t\t\tconst cidStart = reader.pos;\n\t\t\t\tconst cid = readCid(reader);\n\n\t\t\t\tconst bytesStart = reader.pos;\n\t\t\t\tconst bytesSize = entrySize - (bytesStart - cidStart);\n\t\t\t\tconst bytes = reader.exactly(bytesSize, true);\n\n\t\t\t\tconst cidEnd = bytesStart;\n\t\t\t\tconst bytesEnd = reader.pos;\n\t\t\t\tconst entryEnd = bytesEnd;\n\n\t\t\t\tyield {\n\t\t\t\t\tcid,\n\t\t\t\t\tbytes,\n\n\t\t\t\t\tentryStart,\n\t\t\t\t\tentryEnd,\n\t\t\t\t\tcidStart,\n\t\t\t\t\tcidEnd,\n\t\t\t\t\tbytesStart,\n\t\t\t\t\tbytesEnd,\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t[Symbol.iterator](): Iterator<CarEntry> {\n\t\t\treturn this.iterate();\n\t\t},\n\t};\n};\n\nconst createUint8Reader = (buf: Uint8Array): SyncByteReader => {\n\tlet pos = 0;\n\n\treturn {\n\t\tget pos() {\n\t\t\treturn pos;\n\t\t},\n\n\t\tseek(size) {\n\t\t\tif (size > buf.length - pos) {\n\t\t\t\tthrow new RangeError('unexpected end of data');\n\t\t\t}\n\n\t\t\tpos += size;\n\t\t},\n\t\tupto(size) {\n\t\t\treturn buf.subarray(pos, pos + size);\n\t\t},\n\t\texactly(size, seek) {\n\t\t\tif (size > buf.length - pos) {\n\t\t\t\tthrow new RangeError('unexpected end of data');\n\t\t\t}\n\n\t\t\tconst slice = buf.subarray(pos, pos + size);\n\t\t\tif (seek) {\n\t\t\t\tpos += size;\n\t\t\t}\n\n\t\t\treturn slice;\n\t\t},\n\t};\n};\n\nconst readVarint = (reader: SyncByteReader, size: number): number => {\n\tconst buf = reader.upto(size);\n\tif (buf.length === 0) {\n\t\tthrow new RangeError(`unexpected end of data`);\n\t}\n\n\tconst [int, read] = varint.decode(buf);\n\treader.seek(read);\n\n\treturn int;\n};\n\nconst readHeader = (reader: SyncByteReader): CarHeader => {\n\tconst headerStart = reader.pos;\n\tconst length = readVarint(reader, 8);\n\tif (length === 0) {\n\t\tthrow new RangeError(`invalid car header; length=0`);\n\t}\n\n\tconst dataStart = reader.pos;\n\tconst rawHeader = reader.exactly(length, true);\n\n\tconst data = CBOR.decode(rawHeader);\n\tif (!isCarV1Header(data)) {\n\t\tthrow new TypeError(`expected a car v1 archive`);\n\t}\n\n\tconst dataEnd = reader.pos;\n\tconst headerEnd = dataEnd;\n\n\treturn { data, headerStart, headerEnd, dataStart, dataEnd };\n};\n\nconst readCid = (reader: SyncByteReader): CID.Cid => {\n\tconst head = reader.exactly(4, false);\n\n\tconst version = head[0];\n\tconst codec = head[1];\n\tconst digestType = head[2];\n\tconst digestSize = head[3];\n\n\tif (version !== CID.CID_VERSION) {\n\t\tthrow new RangeError(`incorrect cid version (got v${version})`);\n\t}\n\n\tif (codec !== CID.CODEC_DCBOR && codec !== CID.CODEC_RAW) {\n\t\tthrow new RangeError(`incorrect cid codec (got 0x${codec.toString(16)})`);\n\t}\n\n\tif (digestType !== CID.HASH_SHA256) {\n\t\tthrow new RangeError(`incorrect cid digest type (got 0x${digestType.toString(16)})`);\n\t}\n\n\tif (digestSize !== 32 && digestSize !== 0) {\n\t\tthrow new RangeError(`incorrect cid digest size (got ${digestSize})`);\n\t}\n\n\tconst bytes = reader.exactly(4 + digestSize, true);\n\tconst digest = bytes.subarray(4, 4 + digestSize);\n\n\tconst cid: CID.Cid = {\n\t\tversion: version,\n\t\tcodec: codec,\n\t\tdigest: {\n\t\t\tcodec: digestType,\n\t\t\tcontents: digest,\n\t\t},\n\t\tbytes: bytes,\n\t};\n\n\treturn cid;\n};\n", "\n// ### Base Class for HTTP, file, etc. loaders\n// Here the idea is that you can load from multiple schemes, but you might not\n// want to.\nexport class ContentSchemeTileLoader {\n  #schemes;\n  constructor (schemes = ['http', 'file']) {\n    this.#schemes = new Set(schemes);\n  }\n  async load (url, mothership) {\n    const u = new URL(url);\n    if (u.protocol === 'https:' || u.protocol === 'http:') {\n      if (!this.#schemes.has('http')) return false;\n      const res = await fetch(url);\n      if (!res.ok) return false;\n      return await this.processContent(await res.arrayBuffer(), u.protocol, url, mothership);\n    }\n    if (u.protocol === 'file:') {\n      if (!this.#schemes.has('file')) return false;\n      // XXX\n      //  - get the data\n      //  - give it to processContent\n    }\n  }\n}\n", "\nexport const NOT_FOUND = { ok: false, status: 404, statusText: 'Not found' };\n\nexport const maslHeaders = [\n  'content-disposition',\n  'content-encoding',\n  'content-language',\n  'content-security-policy',\n  'content-type',\n  'link',\n  'permissions-policy',\n  'referrer-policy',\n  'service-worker-allowed',\n  'sourcemap',\n  'speculation-rules',\n  'supports-loading-mode',\n  'x-content-type-options',\n];\n\nexport function maslResponse (masl, body) {\n  if (!body) return NOT_FOUND;\n  const headers = {};\n  maslHeaders.forEach(k => {\n    if (typeof masl[k] !== 'undefined') headers[k] = masl[k];\n  });\n  if (typeof body === 'string') body = (new TextEncoder()).encode(body);\n  return { ok: true, status: 200, statusText: 'Ok', headers, body };\n}\n", "\nimport { fromUint8Array } from '@atcute/car';\nimport { toCidLink, toString as stringifyCID } from '@atcute/cid';\nimport { ContentSchemeTileLoader } from \"./content-scheme.js\";\nimport { Tile } from \"../loader.js\";\nimport { NOT_FOUND, maslResponse } from \"../lib/masl.js\";\n\n// ### CAR Tiles\nexport class CARTileLoader extends ContentSchemeTileLoader {\n  constructor (schemes) {\n    super(schemes);\n  }\n  // NOTE: ignoring scheme for now, this is pure HTTP\n  async processContent (carData, scheme, url, mothership) {\n    let car;\n    try {\n      car = fromUint8Array(new Uint8Array(carData));\n    }\n    catch (e) {\n      return false;\n    }\n    console.warn(`car`, car);\n    const { data: manifest } = car.header;\n    delete manifest.version;\n    delete manifest.roots;\n    Object.keys(manifest.resources).forEach(k => {\n      manifest.resources[k].src = toCidLink(manifest.resources[k].src).toJSON();\n    });\n    // This isn't efficient in that it reads the bytes and we throw them away.\n    // We could replace it with a version that skips, but that'd be copying a\n    // lot of work from @atcute; we can optimise later.\n    const offsets = {};\n    for await (const entry of car) {\n      const { cid, bytesStart, bytesEnd } = entry;\n      offsets[stringifyCID(cid)] = [bytesStart, bytesEnd];\n    }\n    const loader = new CARPathLoader(manifest, carData, offsets);\n    return new Tile(mothership, url, manifest, loader);\n  }\n}\n\nexport class CARPathLoader {\n  #manifest;\n  #carData;\n  #offsets;\n  constructor (manifest, carData, offsets) {\n    this.#manifest = manifest;\n    this.#carData = carData;\n    this.#offsets = offsets;\n  }\n  async resolvePath (path) {\n    const entry = this.#manifest?.resources?.[path];\n    if (!entry?.src) return NOT_FOUND;\n    const headers = { ... this.#manifest.resources[path] };\n    const cid = headers.src.$link;\n    delete headers.src;\n    const [start, end] = this.#offsets[cid];\n    return maslResponse(entry, this.#carData.slice(start, end));\n  }\n}\n", "\nimport { TileMothership } from '@dasl/tiles/loader';\nimport { CARTileLoader } from '@dasl/tiles/loader/car';\n\n// CAR Tiles!\nconst car = new CARTileLoader();\n\nconst tl = new TileMothership({ loadDomain: 'load.webtiles.bast' });\ntl.init();\ntl.addLoader(car);\n\nconst parent = document.createElement('div');\nparent.style.display = 'inline-block';\nparent.style.verticalAlign = 'top';\nparent.style.padding = '50px';\nparent.style.width = '570px';\ndocument.body.append(parent);\n\n// XXX demo will break on https\nconst tile = await tl.loadTile(`http:./rick.tile`);\nconsole.warn(`Tile`, tile);\nparent.append(await tile.renderCard({\n  contentHeight: 600,\n}));\n"],
  "mappings": "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",
  "names": ["n", "tile", "a", "b", "c", "e", "f", "g", "i", "j", "k", "toBase64", "toBase64", "toBase64", "decodeFirst", "prelude", "type", "info", "len", "decode", "decode", "readCid", "decode", "car"]
}
