// ../dasl-tiles/lib/el.js
function el(n, attrs, kids, p) {
  const e = document.createElement(n);
  Object.entries(attrs || {}).forEach(([k, v]) => {
    if (v == null) return;
    if (k === "style") {
      Object.entries(v).forEach(([prop, value]) => {
        const snake = prop.split("-").map((part, idx) => idx ? part.charAt(0).toUpperCase() + part.slice(1) : part).join("");
        e.style[snake] = value;
      });
      return;
    }
    e.setAttribute(k, v);
  });
  (kids || []).forEach((n2) => {
    if (typeof n2 === "string") e.append(txt(n2));
    else e.append(n2);
  });
  if (p) p.append(e);
  return e;
}
function txt(str) {
  return document.createTextNode(str);
}

// ../dasl-tiles/loader.js
var TILES_PFX = "tiles-";
var SHUTTLE_PFX = "tiles-shuttle-";
var SND_SHUTTLE_LOAD = `${SHUTTLE_PFX}load`;
var RCV_SHUTTLE_READY = `${SHUTTLE_PFX}ready`;
var SND_SET_TITLE = `${SHUTTLE_PFX}set-title`;
var SND_SET_ICON = `${SHUTTLE_PFX}set-icon`;
var WORKER_PFX = "tiles-worker-";
var SND_WORKER_LOAD = `${WORKER_PFX}load`;
var RCV_WORKER_READY = `${WORKER_PFX}ready`;
var RCV_WORKER_REQUEST = `${WORKER_PFX}request`;
var SND_WORKER_RESPONSE = `${WORKER_PFX}response`;
var TILES_WARNING = `${TILES_PFX}warn`;
var TILES_ERROR = `${TILES_PFX}error`;
var TileMothership = class {
  #loaders = [];
  #conf = {};
  #id2shuttle = /* @__PURE__ */ new Map();
  #id2tile = /* @__PURE__ */ new Map();
  constructor(conf) {
    this.#conf = conf;
  }
  init() {
    window.addEventListener("message", async (ev) => {
      const { action } = ev.data || {};
      if (action === TILES_WARNING) {
        const { msg, id } = ev.data;
        console.warn(`[W:${id}]`, ...msg);
      }
      if (action === TILES_ERROR) {
        const { msg, id } = ev.data;
        console.error(`[S:${id}]`, ...msg);
      } else if (action === RCV_SHUTTLE_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] shuttle ready!`);
        this.sendToShuttle(id, SND_WORKER_LOAD, { id });
      } else if (action === RCV_WORKER_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] worker ready!`);
        const tile2 = this.#id2tile.get(id);
        if (!tile2) throw new Error(`No tile shuttle with ID ${id}`);
        tile2.dispatchEvent(new Event("load"));
      } else if (action === RCV_WORKER_REQUEST) {
        const { type, id, payload } = ev.data;
        console.info(`[W:${id}] worker request`, type, id, payload);
        if (type === "resolve-path") {
          const { path, requestId } = payload;
          const tile2 = this.#id2tile.get(id);
          if (!tile2) throw new Error(`No tile shuttle with ID ${id}`);
          const { status, headers, body } = await tile2.resolvePath(path);
          console.info(`[W:${id}] sending back`, status, headers, body);
          this.sendToShuttle(id, SND_WORKER_RESPONSE, { requestId, response: { status, headers, body } });
        }
      }
    });
  }
  sendToShuttle(id, action, payload) {
    console.warn(`sendToShuttle`, id, action, payload);
    const ifr = this.#id2shuttle.get(id);
    if (!ifr) return console.error(`No shuttle for ID ${id}`);
    ifr.contentWindow.postMessage({ id, action, payload }, "*");
  }
  registerShuttleFrame(ifr, tile2) {
    const id = crypto.randomUUID();
    this.#id2shuttle.set(id, ifr);
    this.#id2tile.set(id, tile2);
    return id;
  }
  startShuttle(id) {
    this.sendToShuttle(id, SND_SHUTTLE_LOAD, { id });
  }
  // Adds a loader that will handle matching requests to load a tile.
  // - `loader` is an object that knows how to load a tile for a specific scheme
  //    (and types)
  addLoader(loader) {
    this.#loaders.push(loader);
  }
  // Remove using same reference.
  removeLoader(loader) {
    this.#loaders = this.#loaders.filter((ldr) => ldr !== loader);
  }
  getLoadSource() {
    return `https://${this.#conf?.loadDomain || "load.webtil.es"}/.well-known/web-tiles/`;
  }
  // Load a tile.
  async loadTile(url) {
    let tile2 = false;
    for (const ldr of this.#loaders) {
      tile2 = await ldr.load(url, this);
      if (tile2) break;
    }
    return tile2;
  }
};
var Tile = class extends EventTarget {
  #mothership;
  #url;
  #manifest;
  #pathLoader;
  #shuttleId;
  constructor(mothership, url, manifest, pathLoader) {
    super();
    this.#mothership = mothership;
    this.#url = url;
    this.#manifest = manifest;
    this.#pathLoader = pathLoader;
    this.addEventListener("load", () => {
      if (this.#manifest?.name) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_TITLE, { title: this.#manifest?.name });
      }
      const icon = this.#manifest?.icons?.[0]?.src;
      if (icon) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_ICON, { path: icon });
      }
    });
  }
  get url() {
    return this.#url;
  }
  get manifest() {
    return this.#manifest;
  }
  async resolvePath(path) {
    const u = new URL(`fake:${path}`);
    return this.#pathLoader.resolvePath(u.pathname);
  }
  async renderCard(options) {
    const card = el("div", { style: {
      border: "1px solid lightgrey",
      "border-radius": "3px",
      cursor: "pointer"
    } });
    card.addEventListener("click", async () => {
      const tileRenderer = await this.renderContent(options?.contentHeight || card.offsetHeight);
      card.replaceWith(tileRenderer);
    });
    if (this.#manifest?.screenshots?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.screenshots[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("div", { style: {
          "background-image": `url(${url})`,
          "background-size": "cover",
          "background-position": "50%",
          "aspect-ratio": "16/9"
        } }, [], card);
      }
    }
    const title = el("div", { style: {
      padding: "0.5rem 1rem",
      display: "flex",
      "align-items": "center"
    } }, [], card);
    if (this.#manifest?.icons?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.icons[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("img", { src: url, width: "48", height: "48", alt: "icon", style: { "padding-right": "0.5rem" } }, [], title);
      }
    }
    el("span", { style: { "font-weight": "bold" } }, [this.#manifest.name || "Untitled Tile"], title);
    if (this.#manifest.description) {
      el("p", { style: { "margin": "0.5rem 1rem 1rem 1rem" } }, [this.#manifest.description], card);
    }
    return card;
  }
  async renderContent(height = 300) {
    const ifr = el("iframe", {
      src: this.#mothership.getLoadSource(),
      style: {
        display: "block",
        width: "100%",
        height: `${height}px`,
        border: "none"
      }
    });
    this.#shuttleId = this.#mothership.registerShuttleFrame(ifr, this);
    ifr.addEventListener("load", () => this.#mothership.startShuttle(this.#shuttleId));
    return ifr;
  }
};

// ../dasl-tiles/node_modules/@atcute/uint8array/dist/index.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var subtle = crypto.subtle;
var _fromCharCode = String.fromCharCode;
var _shortString = (from, p, length) => {
  if (length < 4) {
    if (length < 2) {
      if (length === 0)
        return "";
      const a3 = from[p];
      if (a3 & 128)
        return null;
      return _fromCharCode(a3);
    }
    const a2 = from[p];
    const b2 = from[p + 1];
    if ((a2 | b2) & 128)
      return null;
    if (length === 2)
      return _fromCharCode(a2, b2);
    const c2 = from[p + 2];
    if (c2 & 128)
      return null;
    return _fromCharCode(a2, b2, c2);
  }
  const a = from[p];
  const b = from[p + 1];
  const c = from[p + 2];
  const d = from[p + 3];
  if ((a | b | c | d) & 128)
    return null;
  if (length < 8) {
    if (length === 4)
      return _fromCharCode(a, b, c, d);
    const e2 = from[p + 4];
    if (e2 & 128)
      return null;
    if (length === 5)
      return _fromCharCode(a, b, c, d, e2);
    const f2 = from[p + 5];
    if (f2 & 128)
      return null;
    if (length === 6)
      return _fromCharCode(a, b, c, d, e2, f2);
    const g2 = from[p + 6];
    if (g2 & 128)
      return null;
    return _fromCharCode(a, b, c, d, e2, f2, g2);
  }
  const e = from[p + 4];
  const f = from[p + 5];
  const g = from[p + 6];
  const h = from[p + 7];
  if ((e | f | g | h) & 128)
    return null;
  if (length < 12) {
    if (length === 8)
      return _fromCharCode(a, b, c, d, e, f, g, h);
    const i2 = from[p + 8];
    if (i2 & 128)
      return null;
    if (length === 9)
      return _fromCharCode(a, b, c, d, e, f, g, h, i2);
    const j2 = from[p + 9];
    if (j2 & 128)
      return null;
    if (length === 10)
      return _fromCharCode(a, b, c, d, e, f, g, h, i2, j2);
    const k2 = from[p + 10];
    if (k2 & 128)
      return null;
    return _fromCharCode(a, b, c, d, e, f, g, h, i2, j2, k2);
  }
  const i = from[p + 8];
  const j = from[p + 9];
  const k = from[p + 10];
  const l = from[p + 11];
  if ((i | j | k | l) & 128)
    return null;
  if (length === 12)
    return _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
  const m = from[p + 12];
  if (m & 128)
    return null;
  if (length === 13)
    return _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
  const n = from[p + 13];
  if (n & 128)
    return null;
  if (length === 14)
    return _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
  const o = from[p + 14];
  if (o & 128)
    return null;
  return _fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
};
var decodeUtf8From = (from, offset = 0, length = from.length) => {
  if (length <= 15) {
    const result = _shortString(from, offset, length);
    if (result !== null)
      return result;
  }
  return textDecoder.decode(from.subarray(offset, offset + length));
};

// ../dasl-tiles/node_modules/@atcute/multibase/dist/utils.js
var createRfc4648Encode = (alphabet, bitsPerChar, pad) => {
  return (bytes) => {
    const mask = (1 << bitsPerChar) - 1;
    let str = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < bytes.length; ++i) {
      buffer = buffer << 8 | bytes[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        str += alphabet[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      str += alphabet[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((str.length * bitsPerChar & 7) !== 0) {
        str += "=";
      }
    }
    return str;
  };
};

// ../dasl-tiles/node_modules/@atcute/multibase/dist/bases/base64-web-native.js
var toBase64 = (bytes) => {
  return bytes.toBase64({ alphabet: "base64", omitPadding: true });
};

// ../dasl-tiles/node_modules/@atcute/multibase/dist/bases/base64-web-polyfill.js
var BASE64_CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var toBase642 = /* @__PURE__ */ createRfc4648Encode(BASE64_CHARSET, 6, false);

// ../dasl-tiles/node_modules/@atcute/multibase/dist/bases/base64-web.js
var HAS_NATIVE_SUPPORT = "fromBase64" in Uint8Array;
var toBase643 = !HAS_NATIVE_SUPPORT ? toBase642 : toBase64;

// ../dasl-tiles/node_modules/@atcute/multibase/dist/bases/base32.js
var BASE32_CHARSET = "abcdefghijklmnopqrstuvwxyz234567";
var toBase32 = /* @__PURE__ */ createRfc4648Encode(BASE32_CHARSET, 5, false);

// ../dasl-tiles/node_modules/@atcute/cid/dist/codec.js
var CID_VERSION = 1;
var HASH_SHA256 = 18;
var CODEC_RAW = 85;
var CODEC_DCBOR = 113;
var CID_STRINGIFY_CACHE = /* @__PURE__ */ new WeakMap();
var decodeFirst = (bytes) => {
  const length = bytes.length;
  if (length < 4) {
    throw new RangeError(`cid too short`);
  }
  const version = bytes[0];
  const codec = bytes[1];
  const digestType = bytes[2];
  const digestSize = bytes[3];
  if (version !== CID_VERSION) {
    throw new RangeError(`incorrect cid version (got v${version})`);
  }
  if (codec !== CODEC_DCBOR && codec !== CODEC_RAW) {
    throw new RangeError(`incorrect cid codec (got 0x${codec.toString(16)})`);
  }
  if (digestType !== HASH_SHA256) {
    throw new RangeError(`incorrect cid digest codec (got 0x${digestType.toString(16)})`);
  }
  if (digestSize !== 32 && digestSize !== 0) {
    throw new RangeError(`incorrect cid digest size (got ${digestSize})`);
  }
  if (length < 4 + digestSize) {
    throw new RangeError(`cid too short`);
  }
  const cid = {
    version: CID_VERSION,
    codec,
    digest: {
      codec: digestType,
      contents: bytes.subarray(4, 4 + digestSize)
    },
    bytes: bytes.subarray(0, 4 + digestSize)
  };
  return [cid, bytes.subarray(4 + digestSize)];
};
var decode = (bytes) => {
  const [cid, remainder] = decodeFirst(bytes);
  if (remainder.length !== 0) {
    throw new RangeError(`cid bytes includes remainder`);
  }
  return cid;
};
var toString = (cid) => {
  let str = CID_STRINGIFY_CACHE.get(cid);
  if (str === void 0) {
    str = `b${toBase32(cid.bytes)}`;
    CID_STRINGIFY_CACHE.set(cid, str);
  }
  return str;
};
var fromBinary = (input) => {
  if (input.length !== 37 && input.length !== 5) {
    throw new RangeError(`cid bytes too short`);
  }
  if (input[0] !== 0) {
    throw new SyntaxError(`incorrect binary cid`);
  }
  const bytes = input.subarray(1);
  return decode(bytes);
};

// ../dasl-tiles/node_modules/@atcute/cid/dist/cid-link.js
var CID_LINK_SYMBOL = Symbol.for("@atcute/cid-link-wrapper");
var CIDLINK_STRINGIFY_CACHE = /* @__PURE__ */ new WeakMap();
var CidLinkWrapper = class {
  /** @internal */
  [CID_LINK_SYMBOL] = true;
  bytes;
  constructor(bytes) {
    this.bytes = bytes;
  }
  get $link() {
    let str = CIDLINK_STRINGIFY_CACHE.get(this);
    if (str === void 0) {
      str = `b${toBase32(this.bytes)}`;
      CIDLINK_STRINGIFY_CACHE.set(this, str);
    }
    return str;
  }
  toJSON() {
    return { $link: this.$link };
  }
};
var toCidLink = (cid) => {
  const inst = new CidLinkWrapper(cid.bytes);
  const str = CID_STRINGIFY_CACHE.get(cid);
  if (str !== void 0) {
    CIDLINK_STRINGIFY_CACHE.set(inst, str);
  }
  return inst;
};

// ../dasl-tiles/node_modules/@atcute/cbor/dist/bytes.js
var BYTES_SYMBOL = Symbol.for("@atcute/bytes-wrapper");
var BytesWrapper = class {
  buf;
  /** @internal */
  [BYTES_SYMBOL] = true;
  constructor(buf) {
    this.buf = buf;
  }
  get $bytes() {
    return toBase643(this.buf);
  }
  toJSON() {
    return { $bytes: this.$bytes };
  }
};
var toBytes = (buf) => {
  return new BytesWrapper(buf);
};

// ../dasl-tiles/node_modules/@atcute/cbor/dist/decode.js
var readArgument = (state, info) => {
  if (info < 24) {
    return info;
  }
  let arg;
  switch (info) {
    case 24: {
      arg = readUint8(state);
      if (arg < 24) {
        throw new TypeError(`non-canonical argument encoding`);
      }
      break;
    }
    case 25: {
      arg = readUint16(state);
      if (arg < 256) {
        throw new TypeError(`non-canonical argument encoding`);
      }
      break;
    }
    case 26: {
      arg = readUint32(state);
      if (arg < 65536) {
        throw new TypeError(`non-canonical argument encoding`);
      }
      break;
    }
    case 27: {
      arg = readUint53(state);
      if (arg < 4294967296) {
        throw new TypeError(`non-canonical argument encoding`);
      }
      break;
    }
    default: {
      throw new Error(`invalid argument encoding; got ${info}`);
    }
  }
  return arg;
};
var readFloat64 = (state) => {
  const view = state.v ??= new DataView(state.b.buffer, state.b.byteOffset, state.b.byteLength);
  const value = view.getFloat64(state.p);
  state.p += 8;
  return value;
};
var readUint8 = (state) => {
  return state.b[state.p++];
};
var readUint16 = (state) => {
  let pos = state.p;
  const buf = state.b;
  const value = buf[pos++] << 8 | buf[pos++];
  state.p = pos;
  return value;
};
var readUint32 = (state) => {
  let pos = state.p;
  const buf = state.b;
  const value = (buf[pos++] << 24 | buf[pos++] << 16 | buf[pos++] << 8 | buf[pos++]) >>> 0;
  state.p = pos;
  return value;
};
var readUint53 = (state) => {
  const hi = readUint32(state);
  const lo = readUint32(state);
  if (hi > 2097151) {
    throw new RangeError(`can't decode integers beyond safe integer range`);
  }
  return hi * 2 ** 32 + lo;
};
var readString = (state, length) => {
  const string = decodeUtf8From(state.b, state.p, length);
  state.p += length;
  return string;
};
var readBytes = (state, length) => {
  const slice = state.b.subarray(state.p, state.p += length);
  return toBytes(slice);
};
var readCid = (state, length) => {
  const cid = fromBinary(state.b.subarray(state.p, state.p += length));
  return new CidLinkWrapper(cid.bytes);
};
var compareKeys = (a, b) => {
  return a.length - b.length || (a < b ? -1 : a > b ? 1 : 0);
};
var decodeStringKey = (state) => {
  const prelude = readUint8(state);
  const type = prelude >> 5;
  if (type !== 3) {
    throw new TypeError(`expected map to only have string keys; got type ${type}`);
  }
  const info = prelude & 31;
  const length = readArgument(state, info);
  return readString(state, length);
};
var decodeFirst2 = (buf) => {
  const len = buf.length;
  const state = {
    b: buf,
    v: null,
    p: 0
  };
  let stack = null;
  let value;
  jump: while (state.p < len) {
    const prelude = readUint8(state);
    const type = prelude >> 5;
    const info = prelude & 31;
    const arg = type === 7 ? 0 : readArgument(state, info);
    switch (type) {
      case 0: {
        value = arg;
        break;
      }
      case 1: {
        value = -1 - arg;
        break;
      }
      case 2: {
        value = readBytes(state, arg);
        break;
      }
      case 3: {
        value = readString(state, arg);
        break;
      }
      case 4: {
        if (arg > 0) {
          stack = { t: 1, c: value = new Array(arg), k: null, r: arg, n: stack };
          continue jump;
        }
        value = [];
        break;
      }
      case 5: {
        value = {};
        if (arg > 0) {
          const first = decodeStringKey(state);
          stack = { t: 0, c: value, k: first, r: arg, n: stack };
          continue jump;
        }
        break;
      }
      case 6: {
        switch (arg) {
          case 42: {
            const prelude2 = readUint8(state);
            const type2 = prelude2 >> 5;
            const info2 = prelude2 & 31;
            if (type2 !== 2) {
              throw new TypeError(`expected cid-link to be type 2 (bytes); got type ${type2}`);
            }
            const len2 = readArgument(state, info2);
            value = readCid(state, len2);
            break;
          }
          default: {
            throw new TypeError(`unsupported tag; got ${arg}`);
          }
        }
        break;
      }
      case 7: {
        switch (info) {
          case 20:
          case 21: {
            value = info === 21;
            break;
          }
          case 22: {
            value = null;
            break;
          }
          case 27: {
            value = readFloat64(state);
            break;
          }
          default: {
            throw new Error(`invalid simple value; got ${info}`);
          }
        }
        break;
      }
      default: {
        throw new TypeError(`invalid type; got ${type}`);
      }
    }
    while (stack !== null) {
      switch (stack.t) {
        case 0: {
          const obj = stack.c;
          const key = stack.k;
          if (key === "__proto__") {
            Object.defineProperty(obj, key, { enumerable: true, configurable: true, writable: true });
          }
          obj[key] = value;
          break;
        }
        case 1: {
          const arr = stack.c;
          const index = arr.length - stack.r;
          arr[index] = value;
          break;
        }
      }
      if (--stack.r) {
        if (!stack.t) {
          const prevKey = stack.k;
          stack.k = decodeStringKey(state);
          if (compareKeys(stack.k, prevKey) <= 0) {
            throw new TypeError(`map keys are not in canonical order or contain duplicates`);
          }
        }
        continue jump;
      }
      value = stack.c;
      stack = stack.n;
    }
    break;
  }
  return [value, buf.subarray(state.p)];
};
var decode2 = (buf) => {
  const [value, remainder] = decodeFirst2(buf);
  if (remainder.length !== 0) {
    throw new Error(`decoded value contains remainder`);
  }
  return value;
};

// ../dasl-tiles/node_modules/@atcute/varint/dist/index.js
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = 2 ** 31;
var N1 = 2 ** 7;
var N2 = 2 ** 14;
var N3 = 2 ** 21;
var N4 = 2 ** 28;
var N5 = 2 ** 35;
var N6 = 2 ** 42;
var N7 = 2 ** 49;
var N8 = 2 ** 56;
var N9 = 2 ** 63;
var decode3 = (buf, offset = 0) => {
  let l = buf.length;
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  do {
    if (counter >= l) {
      throw new RangeError("could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);
  return [res, counter - offset];
};

// ../dasl-tiles/node_modules/@atcute/car/dist/types.js
var isCarV1Header = (value) => {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const { version, roots } = value;
  return version === 1 && Array.isArray(roots) && roots.every((root) => root instanceof CidLinkWrapper);
};

// ../dasl-tiles/node_modules/@atcute/car/dist/reader.js
var fromUint8Array = (buffer) => {
  const reader = createUint8Reader(buffer);
  const header = readHeader(reader);
  return {
    header,
    roots: header.data.roots,
    *iterate() {
      while (reader.upto(8 + 36).length > 0) {
        const entryStart = reader.pos;
        const entrySize = readVarint(reader, 8);
        const cidStart = reader.pos;
        const cid = readCid2(reader);
        const bytesStart = reader.pos;
        const bytesSize = entrySize - (bytesStart - cidStart);
        const bytes = reader.exactly(bytesSize, true);
        const cidEnd = bytesStart;
        const bytesEnd = reader.pos;
        const entryEnd = bytesEnd;
        yield {
          cid,
          bytes,
          entryStart,
          entryEnd,
          cidStart,
          cidEnd,
          bytesStart,
          bytesEnd
        };
      }
    },
    [Symbol.iterator]() {
      return this.iterate();
    }
  };
};
var createUint8Reader = (buf) => {
  let pos = 0;
  return {
    get pos() {
      return pos;
    },
    seek(size) {
      if (size > buf.length - pos) {
        throw new RangeError("unexpected end of data");
      }
      pos += size;
    },
    upto(size) {
      return buf.subarray(pos, pos + size);
    },
    exactly(size, seek) {
      if (size > buf.length - pos) {
        throw new RangeError("unexpected end of data");
      }
      const slice = buf.subarray(pos, pos + size);
      if (seek) {
        pos += size;
      }
      return slice;
    }
  };
};
var readVarint = (reader, size) => {
  const buf = reader.upto(size);
  if (buf.length === 0) {
    throw new RangeError(`unexpected end of data`);
  }
  const [int, read] = decode3(buf);
  reader.seek(read);
  return int;
};
var readHeader = (reader) => {
  const headerStart = reader.pos;
  const length = readVarint(reader, 8);
  if (length === 0) {
    throw new RangeError(`invalid car header; length=0`);
  }
  const dataStart = reader.pos;
  const rawHeader = reader.exactly(length, true);
  const data = decode2(rawHeader);
  if (!isCarV1Header(data)) {
    throw new TypeError(`expected a car v1 archive`);
  }
  const dataEnd = reader.pos;
  const headerEnd = dataEnd;
  return { data, headerStart, headerEnd, dataStart, dataEnd };
};
var readCid2 = (reader) => {
  const head = reader.exactly(4, false);
  const version = head[0];
  const codec = head[1];
  const digestType = head[2];
  const digestSize = head[3];
  if (version !== CID_VERSION) {
    throw new RangeError(`incorrect cid version (got v${version})`);
  }
  if (codec !== CODEC_DCBOR && codec !== CODEC_RAW) {
    throw new RangeError(`incorrect cid codec (got 0x${codec.toString(16)})`);
  }
  if (digestType !== HASH_SHA256) {
    throw new RangeError(`incorrect cid digest type (got 0x${digestType.toString(16)})`);
  }
  if (digestSize !== 32 && digestSize !== 0) {
    throw new RangeError(`incorrect cid digest size (got ${digestSize})`);
  }
  const bytes = reader.exactly(4 + digestSize, true);
  const digest = bytes.subarray(4, 4 + digestSize);
  const cid = {
    version,
    codec,
    digest: {
      codec: digestType,
      contents: digest
    },
    bytes
  };
  return cid;
};

// ../dasl-tiles/loader/content-scheme.js
var ContentSchemeTileLoader = class {
  #schemes;
  constructor(schemes = ["http", "file"]) {
    this.#schemes = new Set(schemes);
  }
  async load(url, mothership) {
    const u = new URL(url);
    if (u.protocol === "https:" || u.protocol === "http:") {
      if (!this.#schemes.has("http")) return false;
      const res = await fetch(url);
      if (!res.ok) return false;
      return await this.processContent(await res.arrayBuffer(), u.protocol, url, mothership);
    }
    if (u.protocol === "file:") {
      if (!this.#schemes.has("file")) return false;
    }
  }
};

// ../dasl-tiles/lib/masl.js
var NOT_FOUND = { ok: false, status: 404, statusText: "Not found" };
var maslHeaders = [
  "content-disposition",
  "content-encoding",
  "content-language",
  "content-security-policy",
  "content-type",
  "link",
  "permissions-policy",
  "referrer-policy",
  "service-worker-allowed",
  "sourcemap",
  "speculation-rules",
  "supports-loading-mode",
  "x-content-type-options"
];
function maslResponse(masl, body) {
  if (!body) return NOT_FOUND;
  const headers = {};
  maslHeaders.forEach((k) => {
    if (typeof masl[k] !== "undefined") headers[k] = masl[k];
  });
  if (typeof body === "string") body = new TextEncoder().encode(body);
  return { ok: true, status: 200, statusText: "Ok", headers, body };
}

// ../dasl-tiles/loader/car.js
var CARTileLoader = class extends ContentSchemeTileLoader {
  constructor(schemes) {
    super(schemes);
  }
  // NOTE: ignoring scheme for now, this is pure HTTP
  async processContent(carData, scheme, url, mothership) {
    let car2;
    try {
      car2 = fromUint8Array(new Uint8Array(carData));
    } catch (e) {
      return false;
    }
    console.warn(`car`, car2);
    const { data: manifest } = car2.header;
    delete manifest.version;
    delete manifest.roots;
    Object.keys(manifest.resources).forEach((k) => {
      manifest.resources[k].src = toCidLink(manifest.resources[k].src).toJSON();
    });
    const offsets = {};
    for await (const entry of car2) {
      const { cid, bytesStart, bytesEnd } = entry;
      offsets[toString(cid)] = [bytesStart, bytesEnd];
    }
    const loader = new CARPathLoader(manifest, carData, offsets);
    return new Tile(mothership, url, manifest, loader);
  }
};
var CARPathLoader = class {
  #manifest;
  #carData;
  #offsets;
  constructor(manifest, carData, offsets) {
    this.#manifest = manifest;
    this.#carData = carData;
    this.#offsets = offsets;
  }
  async resolvePath(path) {
    const entry = this.#manifest?.resources?.[path];
    if (!entry?.src) return NOT_FOUND;
    const headers = { ...this.#manifest.resources[path] };
    const cid = headers.src.$link;
    delete headers.src;
    const [start, end] = this.#offsets[cid];
    return maslResponse(entry, this.#carData.slice(start, end));
  }
};

// public/demos/car/car.js
var car = new CARTileLoader();
var tl = new TileMothership({ loadDomain: "load.webtiles.bast" });
tl.init();
tl.addLoader(car);
var parent = document.createElement("div");
parent.style.display = "inline-block";
parent.style.verticalAlign = "top";
parent.style.padding = "50px";
parent.style.width = "570px";
document.body.append(parent);
var tile = await tl.loadTile(`http:./rick.tile`);
console.warn(`Tile`, tile);
parent.append(await tile.renderCard({
  contentHeight: 600
}));
//# sourceMappingURL=car.min.js.map
