// node_modules/@dasl/tiles/lib/el.js
function el(n, attrs, kids, p) {
  const e = document.createElement(n);
  Object.entries(attrs || {}).forEach(([k, v]) => {
    if (v == null) return;
    if (k === "style") {
      Object.entries(v).forEach(([prop, value]) => {
        const snake = prop.split("-").map((part, idx) => idx ? part.charAt(0).toUpperCase() + part.slice(1) : part).join("");
        e.style[snake] = value;
      });
      return;
    }
    e.setAttribute(k, v);
  });
  (kids || []).forEach((n2) => {
    if (typeof n2 === "string") e.append(txt(n2));
    else e.append(n2);
  });
  if (p) p.append(e);
  return e;
}
function txt(str) {
  return document.createTextNode(str);
}

// node_modules/@dasl/tiles/loader.js
var TILES_PFX = "tiles-";
var SHUTTLE_PFX = "tiles-shuttle-";
var SND_SHUTTLE_LOAD = `${SHUTTLE_PFX}load`;
var RCV_SHUTTLE_READY = `${SHUTTLE_PFX}ready`;
var SND_SET_TITLE = `${SHUTTLE_PFX}set-title`;
var SND_SET_ICON = `${SHUTTLE_PFX}set-icon`;
var WORKER_PFX = "tiles-worker-";
var SND_WORKER_LOAD = `${WORKER_PFX}load`;
var RCV_WORKER_READY = `${WORKER_PFX}ready`;
var RCV_WORKER_REQUEST = `${WORKER_PFX}request`;
var SND_WORKER_RESPONSE = `${WORKER_PFX}response`;
var TILES_WARNING = `${TILES_PFX}warn`;
var TILES_ERROR = `${TILES_PFX}error`;
var TileMothership = class {
  #loaders = [];
  #conf = {};
  #id2shuttle = /* @__PURE__ */ new Map();
  #id2tile = /* @__PURE__ */ new Map();
  constructor(conf) {
    this.#conf = conf;
  }
  init() {
    window.addEventListener("message", async (ev) => {
      const { action } = ev.data || {};
      if (action === TILES_WARNING) {
        const { msg, id } = ev.data;
        console.warn(`[W:${id}]`, ...msg);
      }
      if (action === TILES_ERROR) {
        const { msg, id } = ev.data;
        console.error(`[S:${id}]`, ...msg);
      } else if (action === RCV_SHUTTLE_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] shuttle ready!`);
        this.sendToShuttle(id, SND_WORKER_LOAD, { id });
      } else if (action === RCV_WORKER_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] worker ready!`);
        const tile = this.#id2tile.get(id);
        if (!tile) throw new Error(`No tile shuttle with ID ${id}`);
        tile.dispatchEvent(new Event("load"));
      } else if (action === RCV_WORKER_REQUEST) {
        const { type, id, payload } = ev.data;
        console.info(`[W:${id}] worker request`, type, id, payload);
        if (type === "resolve-path") {
          const { path, requestId } = payload;
          const tile = this.#id2tile.get(id);
          if (!tile) throw new Error(`No tile shuttle with ID ${id}`);
          const { status, headers, body } = await tile.resolvePath(path);
          console.info(`[W:${id}] sending back`, status, headers, body);
          this.sendToShuttle(id, SND_WORKER_RESPONSE, { requestId, response: { status, headers, body } });
        }
      }
    });
  }
  sendToShuttle(id, action, payload) {
    console.warn(`sendToShuttle`, id, action, payload);
    const ifr = this.#id2shuttle.get(id);
    if (!ifr) return console.error(`No shuttle for ID ${id}`);
    ifr.contentWindow.postMessage({ id, action, payload }, "*");
  }
  registerShuttleFrame(ifr, tile) {
    const id = crypto.randomUUID();
    this.#id2shuttle.set(id, ifr);
    this.#id2tile.set(id, tile);
    return id;
  }
  startShuttle(id) {
    this.sendToShuttle(id, SND_SHUTTLE_LOAD, { id });
  }
  // Adds a loader that will handle matching requests to load a tile.
  // - `loader` is an object that knows how to load a tile for a specific scheme
  //    (and types)
  addLoader(loader) {
    this.#loaders.push(loader);
  }
  // Remove using same reference.
  removeLoader(loader) {
    this.#loaders = this.#loaders.filter((ldr) => ldr !== loader);
  }
  getLoadSource() {
    return `https://${this.#conf?.loadDomain || "load.webtil.es"}/.well-known/web-tiles/`;
  }
  // Load a tile.
  async loadTile(url) {
    let tile = false;
    for (const ldr of this.#loaders) {
      tile = await ldr.load(url, this);
      if (tile) break;
    }
    return tile;
  }
};
var Tile = class extends EventTarget {
  #mothership;
  #url;
  #manifest;
  #pathLoader;
  #shuttleId;
  constructor(mothership, url, manifest, pathLoader) {
    super();
    this.#mothership = mothership;
    this.#url = url;
    this.#manifest = manifest;
    this.#pathLoader = pathLoader;
    this.addEventListener("load", () => {
      if (this.#manifest?.name) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_TITLE, { title: this.#manifest?.name });
      }
      const icon = this.#manifest?.icons?.[0]?.src;
      if (icon) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_ICON, { path: icon });
      }
    });
  }
  get url() {
    return this.#url;
  }
  get manifest() {
    return this.#manifest;
  }
  async resolvePath(path) {
    const u = new URL(`fake:${path}`);
    return this.#pathLoader.resolvePath(u.pathname);
  }
  async renderCard(options) {
    const card = el("div", { style: {
      border: "1px solid lightgrey",
      "border-radius": "3px",
      cursor: "pointer"
    } });
    card.addEventListener("click", async () => {
      const tileRenderer = await this.renderContent(
        options?.contentHeight || this.#manifest?.sizing?.height || Math.max(card.offsetHeight, 300)
      );
      card.replaceWith(tileRenderer);
    });
    if (this.#manifest?.screenshots?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.screenshots[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("div", { style: {
          "background-image": `url(${url})`,
          "background-size": "cover",
          "background-position": "50%",
          "aspect-ratio": "16/9"
        } }, [], card);
      }
    }
    const title = el("div", { style: {
      padding: "0.5rem 1rem",
      display: "flex",
      "align-items": "center"
    } }, [], card);
    if (this.#manifest?.icons?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.icons[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("img", { src: url, width: "48", height: "48", alt: "icon", style: { "padding-right": "0.5rem" } }, [], title);
      }
    }
    el("span", { style: { "font-weight": "bold" } }, [this.#manifest.name || "Untitled Tile"], title);
    if (this.#manifest.description) {
      el("p", { style: { "margin": "0.5rem 1rem 1rem 1rem" } }, [this.#manifest.description], card);
    }
    return card;
  }
  async renderContent(height = 300) {
    const ifr = el("iframe", {
      src: this.#mothership.getLoadSource(),
      style: {
        display: "block",
        width: "100%",
        height: `${height}px`,
        border: "none"
      }
    });
    this.#shuttleId = this.#mothership.registerShuttleFrame(ifr, this);
    ifr.addEventListener("load", () => this.#mothership.startShuttle(this.#shuttleId));
    return ifr;
  }
};

// node_modules/@dasl/tiles/lib/masl.js
var NOT_FOUND = { ok: false, status: 404, statusText: "Not found" };
var maslHeaders = [
  "content-disposition",
  "content-encoding",
  "content-language",
  "content-security-policy",
  "content-type",
  "link",
  "permissions-policy",
  "referrer-policy",
  "service-worker-allowed",
  "sourcemap",
  "speculation-rules",
  "supports-loading-mode",
  "x-content-type-options"
];
function maslResponse(masl, body) {
  if (!body) return NOT_FOUND;
  const headers = {};
  maslHeaders.forEach((k) => {
    if (typeof masl[k] !== "undefined") headers[k] = masl[k];
  });
  if (typeof body === "string") body = new TextEncoder().encode(body);
  return { ok: true, status: 200, statusText: "Ok", headers, body };
}

// node_modules/@dasl/tiles/loader/memory.js
var MemoryTileLoader = class {
  #tiles = {};
  addTile(id, manifest) {
    this.#tiles[id] = manifest;
  }
  async load(url, mothership) {
    const u = new URL(url);
    if (u.protocol !== "memory:") return false;
    const id = u.hostname;
    if (!this.#tiles[id]) return false;
    const manifest = this.#tiles[id];
    const loader = new MemoryPathLoader(manifest);
    return new Tile(mothership, url, manifest, loader);
  }
};
var MemoryPathLoader = class {
  #manifest;
  constructor(manifest) {
    this.#manifest = manifest;
  }
  async resolvePath(path) {
    const entry = this.#manifest?.resources?.[path];
    if (!entry?.src) return NOT_FOUND;
    return maslResponse(entry, entry.src);
  }
};

// public/demos/experiment/experiment.js
var mem = new MemoryTileLoader();
var colours = {
  green: "oklch(69.3% 0.151 180)",
  light: "oklch(79.3% 0.136 270)",
  dark: "oklch(54.3% 0.091 270)",
  pink: "oklch(74.3% 0.143 0.31)",
  yellow: "oklch(89.3% 0.121 90.3)"
};
var tl = new TileMothership({ loadDomain: "load.webtiles.bast" });
tl.init();
tl.addLoader(mem);
for (const ent of Object.entries(colours)) {
  const [id, colour] = ent;
  mem.addTile(id, {
    name: `Basic ${id} Tile`,
    description: `This is a very simple tile that we can load from memory and that has enough content to be worth playing with. It comes in ${colour} shade.`,
    screenshots: [{ src: "/img/shot" }],
    icons: [{ src: `/img/icon` }],
    resources: {
      "/": {
        src: `<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Tile!</title>
              <link rel="stylesheet" href="/style.css"></head><body><p>hi from ${colour}!</p></body></html>`,
        "content-type": "text/html"
      },
      "/style.css": {
        src: `body { background: ${colour}; }
`,
        "content-type": "text/css"
      },
      "/img/shot": {
        src: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1600 900" width="1600">
          <rect x="0" y="0" width="100%" height="100%" fill="${colour}"></rect>
          <circle cx="50%" cy="50%" r="300" fill="lime"></circle>
        </svg>`,
        "content-type": "image/svg+xml"
      },
      "/img/icon": {
        src: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="48px">
          <circle cx="50%" cy="50%" r="20" fill="${colour}"></circle>
        </svg>`,
        "content-type": "image/svg+xml"
      }
    }
  });
  const parent = document.createElement("div");
  parent.style.display = "inline-block";
  parent.style.verticalAlign = "top";
  parent.style.padding = "50px";
  parent.style.width = "570px";
  document.body.append(parent);
  const tile = await tl.loadTile(`memory://${id}`);
  parent.append(await tile.renderCard());
}
//# sourceMappingURL=experiment.min.js.map
