// node_modules/@dasl/tiles/lib/el.js
function el(n, attrs, kids, p) {
  const e = document.createElement(n);
  Object.entries(attrs || {}).forEach(([k, v]) => {
    if (v == null) return;
    if (k === "style") {
      Object.entries(v).forEach(([prop, value]) => {
        const snake = prop.split("-").map((part, idx) => idx ? part.charAt(0).toUpperCase() + part.slice(1) : part).join("");
        e.style[snake] = value;
      });
      return;
    }
    e.setAttribute(k, v);
  });
  (kids || []).forEach((n2) => {
    if (typeof n2 === "string") e.append(txt(n2));
    else e.append(n2);
  });
  if (p) p.append(e);
  return e;
}
function txt(str) {
  return document.createTextNode(str);
}

// node_modules/@dasl/tiles/loader.js
var TILES_PFX = "tiles-";
var SHUTTLE_PFX = "tiles-shuttle-";
var SND_SHUTTLE_LOAD = `${SHUTTLE_PFX}load`;
var RCV_SHUTTLE_READY = `${SHUTTLE_PFX}ready`;
var SND_SET_TITLE = `${SHUTTLE_PFX}set-title`;
var SND_SET_ICON = `${SHUTTLE_PFX}set-icon`;
var WORKER_PFX = "tiles-worker-";
var SND_WORKER_LOAD = `${WORKER_PFX}load`;
var RCV_WORKER_READY = `${WORKER_PFX}ready`;
var RCV_WORKER_REQUEST = `${WORKER_PFX}request`;
var SND_WORKER_RESPONSE = `${WORKER_PFX}response`;
var TILES_WARNING = `${TILES_PFX}warn`;
var TILES_ERROR = `${TILES_PFX}error`;
var TileMothership = class {
  #loaders = [];
  #conf = {};
  #id2shuttle = /* @__PURE__ */ new Map();
  #id2tile = /* @__PURE__ */ new Map();
  constructor(conf) {
    this.#conf = conf;
  }
  init() {
    window.addEventListener("message", async (ev) => {
      const { action } = ev.data || {};
      if (action === TILES_WARNING) {
        const { msg, id } = ev.data;
        console.warn(`[W:${id}]`, ...msg);
      }
      if (action === TILES_ERROR) {
        const { msg, id } = ev.data;
        console.error(`[S:${id}]`, ...msg);
      } else if (action === RCV_SHUTTLE_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] shuttle ready!`);
        this.sendToShuttle(id, SND_WORKER_LOAD, { id });
      } else if (action === RCV_WORKER_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] worker ready!`);
        const tile2 = this.#id2tile.get(id);
        if (!tile2) throw new Error(`No tile shuttle with ID ${id}`);
        tile2.dispatchEvent(new Event("load"));
      } else if (action === RCV_WORKER_REQUEST) {
        const { type, id, payload } = ev.data;
        console.info(`[W:${id}] worker request`, type, id, payload);
        if (type === "resolve-path") {
          const { path, requestId } = payload;
          const tile2 = this.#id2tile.get(id);
          if (!tile2) throw new Error(`No tile shuttle with ID ${id}`);
          const { status, headers, body } = await tile2.resolvePath(path);
          console.info(`[W:${id}] sending back`, status, headers, body);
          this.sendToShuttle(id, SND_WORKER_RESPONSE, { requestId, response: { status, headers, body } });
        }
      }
    });
  }
  sendToShuttle(id, action, payload) {
    console.warn(`sendToShuttle`, id, action, payload);
    const ifr = this.#id2shuttle.get(id);
    if (!ifr) return console.error(`No shuttle for ID ${id}`);
    ifr.contentWindow.postMessage({ id, action, payload }, "*");
  }
  registerShuttleFrame(ifr, tile2) {
    const id = crypto.randomUUID();
    this.#id2shuttle.set(id, ifr);
    this.#id2tile.set(id, tile2);
    return id;
  }
  startShuttle(id) {
    this.sendToShuttle(id, SND_SHUTTLE_LOAD, { id });
  }
  // Adds a loader that will handle matching requests to load a tile.
  // - `loader` is an object that knows how to load a tile for a specific scheme
  //    (and types)
  addLoader(loader) {
    this.#loaders.push(loader);
  }
  // Remove using same reference.
  removeLoader(loader) {
    this.#loaders = this.#loaders.filter((ldr) => ldr !== loader);
  }
  getLoadSource() {
    return `https://${this.#conf?.loadDomain || "load.webtil.es"}/.well-known/web-tiles/`;
  }
  // Load a tile.
  async loadTile(url) {
    let tile2 = false;
    for (const ldr of this.#loaders) {
      tile2 = await ldr.load(url, this);
      if (tile2) break;
    }
    return tile2;
  }
};
var Tile = class extends EventTarget {
  #mothership;
  #url;
  #manifest;
  #pathLoader;
  #shuttleId;
  constructor(mothership, url, manifest, pathLoader) {
    super();
    this.#mothership = mothership;
    this.#url = url;
    this.#manifest = manifest;
    this.#pathLoader = pathLoader;
    this.addEventListener("load", () => {
      if (this.#manifest?.name) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_TITLE, { title: this.#manifest?.name });
      }
      const icon = this.#manifest?.icons?.[0]?.src;
      if (icon) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_ICON, { path: icon });
      }
    });
  }
  get url() {
    return this.#url;
  }
  get manifest() {
    return this.#manifest;
  }
  async resolvePath(path) {
    const u = new URL(`fake:${path}`);
    return this.#pathLoader.resolvePath(u.pathname);
  }
  async renderCard(options) {
    const card = el("div", { style: {
      border: "1px solid lightgrey",
      "border-radius": "3px",
      cursor: "pointer"
    } });
    card.addEventListener("click", async () => {
      const tileRenderer = await this.renderContent(
        options?.contentHeight || this.#manifest?.sizing?.height || Math.max(card.offsetHeight, 300)
      );
      card.replaceWith(tileRenderer);
    });
    if (this.#manifest?.screenshots?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.screenshots[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("div", { style: {
          "background-image": `url(${url})`,
          "background-size": "cover",
          "background-position": "50%",
          "aspect-ratio": "16/9"
        } }, [], card);
      }
    }
    const title = el("div", { style: {
      padding: "0.5rem 1rem",
      display: "flex",
      "align-items": "center"
    } }, [], card);
    if (this.#manifest?.icons?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.icons[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("img", { src: url, width: "48", height: "48", alt: "icon", style: { "padding-right": "0.5rem" } }, [], title);
      }
    }
    el("span", { style: { "font-weight": "bold" } }, [this.#manifest.name || "Untitled Tile"], title);
    if (this.#manifest.description) {
      el("p", { style: { "margin": "0.5rem 1rem 1rem 1rem" } }, [this.#manifest.description], card);
    }
    return card;
  }
  async renderContent(height = 300) {
    const ifr = el("iframe", {
      src: this.#mothership.getLoadSource(),
      style: {
        display: "block",
        width: "100%",
        height: `${height}px`,
        border: "none"
      }
    });
    this.#shuttleId = this.#mothership.registerShuttleFrame(ifr, this);
    ifr.addEventListener("load", () => this.#mothership.startShuttle(this.#shuttleId));
    return ifr;
  }
};

// node_modules/@dasl/tiles/lib/masl.js
var NOT_FOUND = { ok: false, status: 404, statusText: "Not found" };
var maslHeaders = [
  "content-disposition",
  "content-encoding",
  "content-language",
  "content-security-policy",
  "content-type",
  "link",
  "permissions-policy",
  "referrer-policy",
  "service-worker-allowed",
  "sourcemap",
  "speculation-rules",
  "supports-loading-mode",
  "x-content-type-options"
];
function maslResponse(masl, body) {
  if (!body) return NOT_FOUND;
  const headers = {};
  maslHeaders.forEach((k) => {
    if (typeof masl[k] !== "undefined") headers[k] = masl[k];
  });
  if (typeof body === "string") body = new TextEncoder().encode(body);
  return { ok: true, status: 200, statusText: "Ok", headers, body };
}

// node_modules/@dasl/tiles/loader/at.js
async function did2pds(did) {
  if (!/^did:plc:/.test(did)) return false;
  const res = await fetch(`https://plc.directory/${did}`);
  if (!res.ok) return false;
  const doc = await res.json();
  const pds = doc.service?.find((s) => s.id === "#atproto_pds")?.serviceEndpoint;
  return pds;
}
async function fetchFromPDS(did, query, params) {
  const pds = await did2pds(did);
  if (!pds) return;
  const url = new URL(pds);
  url.pathname = `/xrpc/${query}`;
  const prm = url.searchParams;
  Object.entries(params).forEach(([k, v]) => prm.set(k, v));
  return await fetch(url.toString());
}
async function getRecord(repo, collection, rkey) {
  const res = await fetchFromPDS(repo, "com.atproto.repo.getRecord", { repo, collection, rkey });
  if (!res.ok) return false;
  return await res.json();
}
async function getBlob(did, cid) {
  const res = await fetchFromPDS(did, "com.atproto.sync.getBlob", { did, cid });
  if (!res.ok) return false;
  return await res.arrayBuffer();
}
var ATTileLoader = class {
  async load(url, mothership) {
    if (!/^at:\/\//.test(url)) return false;
    const [repo, collection, rkey] = url.replace(/^at:\/\//, "").split("/");
    if (collection !== "ing.dasl.masl") return;
    const res = await getRecord(repo, collection, rkey);
    if (!res) return false;
    const manifest = res.value?.tile;
    if (!manifest) return false;
    const loader = new ATPathLoader(repo, manifest);
    return new Tile(mothership, url, manifest, loader);
  }
};
var ATPathLoader = class {
  #did;
  #manifest;
  constructor(did, manifest) {
    this.#did = did;
    this.#manifest = manifest;
  }
  async resolvePath(path) {
    const entry = this.#manifest?.resources?.[path];
    if (!entry?.src) return NOT_FOUND;
    const cid = entry.src.$link || entry.src.ref.$link;
    const data = await getBlob(this.#did, cid);
    if (!data) return NOT_FOUND;
    return maslResponse(entry, data);
  }
};

// public/demos/at/at.js
var loadDomain = /localhost|\.bast/.test(window.location.hostname) ? "load.webtiles.bast" : "load.webtil.es";
var at = new ATTileLoader();
var tl = new TileMothership({ loadDomain });
tl.init();
tl.addLoader(at);
var parent = document.createElement("div");
parent.style.display = "inline-block";
parent.style.verticalAlign = "top";
parent.style.padding = "50px";
parent.style.width = "570px";
document.body.append(parent);
var tile = await tl.loadTile(`at://did:plc:izttpdp3l6vss5crelt5kcux/ing.dasl.masl/3mcjwwoqjqs2v`);
console.warn(`Tile`, tile);
parent.append(await tile.renderCard());
//# sourceMappingURL=at.min.js.map
