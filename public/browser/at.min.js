// node_modules/@dasl/tiles/lib/el.js
function el(n, attrs, kids, p) {
  const e = document.createElement(n);
  Object.entries(attrs || {}).forEach(([k, v]) => {
    if (v == null) return;
    if (k === "style") {
      Object.entries(v).forEach(([prop, value]) => {
        const snake = prop.split("-").map((part, idx) => idx ? part.charAt(0).toUpperCase() + part.slice(1) : part).join("");
        e.style[snake] = value;
      });
      return;
    }
    e.setAttribute(k, v);
  });
  (kids || []).forEach((n2) => {
    if (typeof n2 === "string") e.append(txt(n2));
    else e.append(n2);
  });
  if (p) p.append(e);
  return e;
}
function txt(str) {
  return document.createTextNode(str);
}

// node_modules/@dasl/tiles/loader.js
var TILES_PFX = "tiles-";
var SHUTTLE_PFX = "tiles-shuttle-";
var SND_SHUTTLE_LOAD = `${SHUTTLE_PFX}load`;
var RCV_SHUTTLE_READY = `${SHUTTLE_PFX}ready`;
var SND_SET_TITLE = `${SHUTTLE_PFX}set-title`;
var SND_SET_ICON = `${SHUTTLE_PFX}set-icon`;
var WORKER_PFX = "tiles-worker-";
var SND_WORKER_LOAD = `${WORKER_PFX}load`;
var RCV_WORKER_READY = `${WORKER_PFX}ready`;
var RCV_WORKER_REQUEST = `${WORKER_PFX}request`;
var SND_WORKER_RESPONSE = `${WORKER_PFX}response`;
var TILES_WARNING = `${TILES_PFX}warn`;
var TILES_ERROR = `${TILES_PFX}error`;
var TileMothership = class {
  #loaders = [];
  #conf = {};
  #id2shuttle = /* @__PURE__ */ new Map();
  #id2tile = /* @__PURE__ */ new Map();
  constructor(conf) {
    this.#conf = conf;
  }
  init() {
    window.addEventListener("message", async (ev) => {
      const { action } = ev.data || {};
      if (action === TILES_WARNING) {
        const { msg, id } = ev.data;
        console.warn(`[W:${id}]`, ...msg);
      }
      if (action === TILES_ERROR) {
        const { msg, id } = ev.data;
        console.error(`[S:${id}]`, ...msg);
      } else if (action === RCV_SHUTTLE_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] shuttle ready!`);
        this.sendToShuttle(id, SND_WORKER_LOAD, { id });
      } else if (action === RCV_WORKER_READY) {
        const { id } = ev.data;
        console.info(`[W:${id}] worker ready!`);
        const tile = this.#id2tile.get(id);
        if (!tile) throw new Error(`No tile shuttle with ID ${id}`);
        tile.dispatchEvent(new Event("load"));
      } else if (action === RCV_WORKER_REQUEST) {
        const { type, id, payload } = ev.data;
        console.info(`[W:${id}] worker request`, type, id, payload);
        if (type === "resolve-path") {
          const { path, requestId } = payload;
          const tile = this.#id2tile.get(id);
          if (!tile) throw new Error(`No tile shuttle with ID ${id}`);
          const { status, headers, body } = await tile.resolvePath(path);
          console.info(`[W:${id}] sending back`, status, headers, body);
          this.sendToShuttle(id, SND_WORKER_RESPONSE, { requestId, response: { status, headers, body } });
        }
      }
    });
  }
  sendToShuttle(id, action, payload) {
    console.warn(`sendToShuttle`, id, action, payload);
    const ifr = this.#id2shuttle.get(id);
    if (!ifr) return console.error(`No shuttle for ID ${id}`);
    ifr.contentWindow.postMessage({ id, action, payload }, "*");
  }
  registerShuttleFrame(ifr, tile) {
    const id = crypto.randomUUID();
    this.#id2shuttle.set(id, ifr);
    this.#id2tile.set(id, tile);
    return id;
  }
  startShuttle(id) {
    this.sendToShuttle(id, SND_SHUTTLE_LOAD, { id });
  }
  // Adds a loader that will handle matching requests to load a tile.
  // - `loader` is an object that knows how to load a tile for a specific scheme
  //    (and types)
  addLoader(loader) {
    this.#loaders.push(loader);
  }
  // Remove using same reference.
  removeLoader(loader) {
    this.#loaders = this.#loaders.filter((ldr) => ldr !== loader);
  }
  getLoadSource() {
    return `https://${this.#conf?.loadDomain || "load.webtil.es"}/.well-known/web-tiles/`;
  }
  // Load a tile.
  async loadTile(url) {
    let tile = false;
    for (const ldr of this.#loaders) {
      tile = await ldr.load(url, this);
      if (tile) break;
    }
    return tile;
  }
};
var Tile = class extends EventTarget {
  #mothership;
  #url;
  #manifest;
  #pathLoader;
  #shuttleId;
  constructor(mothership, url, manifest, pathLoader) {
    super();
    this.#mothership = mothership;
    this.#url = url;
    this.#manifest = manifest;
    this.#pathLoader = pathLoader;
    this.addEventListener("load", () => {
      if (this.#manifest?.name) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_TITLE, { title: this.#manifest?.name });
      }
      const icon = this.#manifest?.icons?.[0]?.src;
      if (icon) {
        this.#mothership.sendToShuttle(this.#shuttleId, SND_SET_ICON, { path: icon });
      }
    });
  }
  get url() {
    return this.#url;
  }
  get manifest() {
    return this.#manifest;
  }
  async resolvePath(path) {
    const u = new URL(`fake:${path}`);
    return this.#pathLoader.resolvePath(u.pathname);
  }
  async renderCard(options) {
    const card = el("div", { style: {
      border: "1px solid lightgrey",
      "border-radius": "3px",
      cursor: "pointer"
    } });
    card.addEventListener("click", async () => {
      const tileRenderer = await this.renderContent(
        options?.contentHeight || this.#manifest?.sizing?.height || Math.max(card.offsetHeight, 300)
      );
      card.replaceWith(tileRenderer);
    });
    if (this.#manifest?.screenshots?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.screenshots[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("div", { style: {
          "background-image": `url(${url})`,
          "background-size": "cover",
          "background-position": "50%",
          "aspect-ratio": "16/9"
        } }, [], card);
      }
    }
    const title = el("div", { style: {
      padding: "0.5rem 1rem",
      display: "flex",
      "align-items": "center"
    } }, [], card);
    if (this.#manifest?.icons?.[0]?.src) {
      const res = await this.resolvePath(this.#manifest.icons[0].src);
      if (res.ok) {
        const blob = new Blob([res.body], { type: res.headers?.["content-type"] });
        const url = URL.createObjectURL(blob);
        el("img", { src: url, width: "48", height: "48", alt: "icon", style: { "padding-right": "0.5rem" } }, [], title);
      }
    }
    el("span", { style: { "font-weight": "bold" } }, [this.#manifest.name || "Untitled Tile"], title);
    if (this.#manifest.description) {
      el("p", { style: { "margin": "0.5rem 1rem 1rem 1rem" } }, [this.#manifest.description], card);
    }
    return card;
  }
  async renderContent(height = 300) {
    const ifr = el("iframe", {
      src: this.#mothership.getLoadSource(),
      style: {
        display: "block",
        width: "100%",
        height: `${height}px`,
        border: "none"
      }
    });
    this.#shuttleId = this.#mothership.registerShuttleFrame(ifr, this);
    ifr.addEventListener("load", () => this.#mothership.startShuttle(this.#shuttleId));
    return ifr;
  }
};

// node_modules/@dasl/tiles/lib/masl.js
var NOT_FOUND = { ok: false, status: 404, statusText: "Not found" };
var maslHeaders = [
  "content-disposition",
  "content-encoding",
  "content-language",
  "content-security-policy",
  "content-type",
  "link",
  "permissions-policy",
  "referrer-policy",
  "service-worker-allowed",
  "sourcemap",
  "speculation-rules",
  "supports-loading-mode",
  "x-content-type-options"
];
function maslResponse(masl, body) {
  if (!body) return NOT_FOUND;
  const headers = {};
  maslHeaders.forEach((k) => {
    if (typeof masl[k] !== "undefined") headers[k] = masl[k];
  });
  if (typeof body === "string") body = new TextEncoder().encode(body);
  return { ok: true, status: 200, statusText: "Ok", headers, body };
}

// node_modules/@dasl/tiles/loader/at.js
async function did2pds(did) {
  if (!/^did:plc:/.test(did)) return false;
  const res = await fetch(`https://plc.directory/${did}`);
  if (!res.ok) return false;
  const doc = await res.json();
  const pds = doc.service?.find((s) => s.id === "#atproto_pds")?.serviceEndpoint;
  return pds;
}
async function fetchFromPDS(did, query, params) {
  const pds = await did2pds(did);
  if (!pds) return;
  const url = new URL(pds);
  url.pathname = `/xrpc/${query}`;
  const prm = url.searchParams;
  Object.entries(params).forEach(([k, v]) => prm.set(k, v));
  return await fetch(url.toString());
}
async function getRecord(repo, collection, rkey) {
  const res = await fetchFromPDS(repo, "com.atproto.repo.getRecord", { repo, collection, rkey });
  if (!res.ok) return false;
  return await res.json();
}
async function getBlob(did, cid) {
  const res = await fetchFromPDS(did, "com.atproto.sync.getBlob", { did, cid });
  if (!res.ok) return false;
  return await res.arrayBuffer();
}
var ATTileLoader = class {
  async load(url, mothership) {
    if (!/^at:\/\//.test(url)) return false;
    const [repo, collection, rkey] = url.replace(/^at:\/\//, "").split("/");
    if (collection !== "ing.dasl.masl") return;
    const res = await getRecord(repo, collection, rkey);
    if (!res) return false;
    const manifest = res.value?.tile;
    if (!manifest) return false;
    const loader = new ATPathLoader(repo, manifest);
    return new Tile(mothership, url, manifest, loader);
  }
};
var ATPathLoader = class {
  #did;
  #manifest;
  constructor(did, manifest) {
    this.#did = did;
    this.#manifest = manifest;
  }
  async resolvePath(path) {
    const entry = this.#manifest?.resources?.[path];
    if (!entry?.src) return NOT_FOUND;
    const cid = entry.src.$link || entry.src.ref.$link;
    const data = await getBlob(this.#did, cid);
    if (!data) return NOT_FOUND;
    return maslResponse(entry, data);
  }
};

// node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = /* @__NO_SIDE_EFFECTS__ */ (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/nanostores/effect/index.js
var effect = (stores, callback) => {
  if (!Array.isArray(stores)) stores = [stores];
  let unbinds = [];
  let lastRunUnbind;
  let run = () => {
    lastRunUnbind && lastRunUnbind();
    let values = stores.map((store) => store.get());
    lastRunUnbind = callback(...values);
  };
  unbinds = stores.map((store) => store.listen(run));
  run();
  return () => {
    unbinds.forEach((unbind) => unbind());
    lastRunUnbind && lastRunUnbind();
  };
};

// public/browser/at.js
var loadDomain = /localhost|\.bast/.test(window.location.hostname) ? "load.webtiles.bast" : "load.webtil.es";
var at = new ATTileLoader();
var tl = new TileMothership({ loadDomain });
tl.init();
tl.addLoader(at);
var $url = atom();
var $currentTile = atom();
async function navigate(url) {
  if (!url) return;
  $error.set(null);
  $url.set(url);
  const tile = await tl.loadTile(url);
  console.warn(`Tile`, tile);
  $currentTile.set(tile);
}
function navigateFromHash() {
  const { hash } = window.location;
  const params = {};
  hash.replace(/^#/, "").split("&").filter(Boolean).forEach((prm) => {
    const [k, v] = prm.split(/=/, 2);
    params[k] = typeof v === "undefined" ? true : v;
  });
  navigate(params.url);
}
var $error = atom();
function error(msg) {
  $error.set(msg);
}
var defaultTitle = "ATMOS";
var $title = atom(defaultTitle);
function setTitle(title) {
  $title.set(title || defaultTitle);
}
window.addEventListener("hashchange", navigateFromHash);
window.addEventListener("load", () => {
  const form = document.querySelector("#browser > form");
  const urlBar = form.querySelector('input[name="url"]');
  form.addEventListener("submit", (ev) => {
    ev.preventDefault();
    const url = urlBar.value;
    if (!url) return error("URL is empty!");
    if (!/^at:\/\/[^/]+\/ing\.dasl\.masl\/\w+$/.test(url)) {
      return error(`Syntax error, expected "at://<didOrHandle>/ing.dasl.masl/<tid>"`);
    }
    window.location.hash = `#url=${url}`;
  });
  $url.subscribe((val) => urlBar.value = val || "");
  $title.subscribe((val) => document.querySelector("#browser > h2").textContent = val);
  const titleChangeHandler = (ev) => setTitle(ev.title);
  $currentTile.subscribe((tile, oldTile) => {
    if (tile) tile.addEventListener("title-change", titleChangeHandler);
    if (oldTile) tile.removeEventListener("title-change", titleChangeHandler);
  });
  const rz = document.querySelector("#render-zone");
  effect([$error, $currentTile], async (err, tile) => {
    console.warn(`rndr`, err, tile);
    rz.textContent = null;
    if (err) el2("div", { class: "error" }, [err], rz);
    else if (tile) {
      el2("div", { class: "tile-container" }, [await tile.renderCard()], rz);
    } else el2("div", { class: "nothing" }, ["ATMOS ready to sail the skies."], rz);
    return () => {
    };
  });
  navigateFromHash();
});
function el2(n, attrs, kids, p) {
  const e = document.createElement(n);
  Object.entries(attrs || {}).forEach(([k, v]) => {
    if (v == null) return;
    if (k === "style") {
      Object.entries(v).forEach(([prop, value]) => {
        const snake = prop.split("-").map((part, idx) => idx ? part.charAt(0).toUpperCase() + part.slice(1) : part).join("");
        e.style[snake] = value;
      });
      return;
    }
    e.setAttribute(k, v);
  });
  (kids || []).forEach((n2) => {
    if (typeof n2 === "string") e.append(txt2(n2));
    else e.append(n2);
  });
  if (p) p.append(e);
  return e;
}
function txt2(str) {
  return document.createTextNode(str);
}
export {
  el2 as el
};
//# sourceMappingURL=at.min.js.map
